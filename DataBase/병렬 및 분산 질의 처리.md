## 1. 병렬 정렬

### 1.1 범위 파티셔닝 정렬 (Range-Partitioning Sort)

1. **범위 파티셔닝 단계**

   * 전체 관계를 정렬 속성 기준으로 m개 구간으로 분할
   * 각 노드에서 해당 구간의 튜플 수신 및 로컬 디스크에 저장
2. **로컬 정렬 단계**

   * 각 노드에서 `로컬 정렬` 실행
3. **병합 단계**

   * 정렬된 파티션들을 단순히 연결하여 최종 결과 생성

> **부하 균형**: 균형 있는 파티션 벡터 또는 가상 노드 파티셔닝 이용

### 1.2 병렬 외부 정렬 병합 (Parallel External Sort-Merge)

1. **로컬 정렬**: 각 노드에서 자체 데이터 정렬
2. **범위 파티셔닝 & 병합**

   * 정렬된 런을 같은 파티션 벡터로 재분배
   * 블록 단위 전송으로 병렬 수신
   * 입력이 정렬되어 있으면 `순서 병합` 가능

---

## 2. 병렬 조인

### 2.1 파티션 조인 (Partitioned Join)

* 두 관계 r, s를 동일한 방식(`hash` 또는 `range`)으로 파티셔닝
* 각 노드에서 파티션 ri ⋈ si 를 **로컬**로 계산
* `내부(inner)`, `외부(outer)`, `자연(natural)` 조인 지원

**로컬 조인 기법**:

```
// 예시: hash join
1. build 단계: 소규모 파티션 si 메모리 적재 및 해시 인덱스 생성
2. probe 단계: ri 튜플로 index 조회
```

### 2.2 분할-복제 조인 (Fragment-and-Replicate Join)

1. **비대칭(Asymmetric/Broadcast) 조인**

   * 큰 테이블 분할 → 작은 테이블 전체 **복제** → 각 노드에서 조인
2. **대칭(Symmetric) 조인**

   * r을 n개, s를 m개로 분할 → ri를 i행에, sj를 j열에 복제 → 총 n×m 노드에서 ri ⋈ sj

> **용도**: 부등호 조인 등 파티셔닝 불가능한 조건

### 2.3 부하 치우침 처리

* **회피**: 가상 노드 파티셔닝, 적절한 해시/범위 설정
* **동적 처리**: 워크 스틸링으로 idle 노드가 대기 중인 파티션 처리

---

## 3. 병렬 질의 계획 및 실행

### 3.1 병렬성 유형

1. **연산 내부 병렬화**: 데이터 병렬 – 동일 연산을 다양한 노드에서
2. **연산 간 병렬화**:

   * *파이프라인 병렬화*: 생산자→소비자 동시 실행
   * *독립 병렬화*: 서로 의존 없는 연산 동시 실행

### 3.2 교환(Exchange) 연산자 모델

* **분배**: `hash`, `range`, `broadcast`, `single-node` 네 가지 방식
* **병합**: 랜덤 or 정렬된
* 로컬 연산은 병렬성 모름→기존 코드 재사용

```text
Exchange
 ├─ Partition(data)
 └─ Merge(received data)
```

### 3.3 예시: 조인+집계 파이프라인

1. `E1`: r과 s를 조인 속성으로 파티셔닝 → 로컬 Hash Join
2. `E2`: 조인 결과를 그룹 속성으로 파티셔닝 → 로컬 Hash Aggregate
3. `E3`: 최종 결과 수집

> **부분 집계**: 로컬에서 1차 집계 후 파티션 전송 → 최종 집계

---

## 4. 장애 허용(Fault Tolerance)

1. **MapReduce**

   * map 결과를 로컬에 저장 → reduce는 모든 map 완료 후 실행
   * 실패 시 해당 작업만 재실행
2. **Spark **

   * lineage 기록 → 필요 시 연산 재생성
   * 선택적 데이터 복제, 셔플 결과 로컬 캐시
3. **파이프라인 FT**

   * 주기적 체크포인트 → 재시작 시 체크포인트부터 재생
   * 중복 방지 위해 시퀀스 추적

---

## 5. 공유 메모리 환경 (NUMA & SIMD)

* **공유 메모리 최적화**: broadcast 복제 1회, 워크 스틸링
* **공유 해시 조인**:

  1. 작은 파티션마다 로컬 해시 테이블
  2. 단일 공유 해시 테이블 + 락-프리 자료구조 or 모절 스케줄링
* **NUMA 인식**: 스레드 고정, 지역 메모리 할당
* **SIMD/GPU**: 벡터화 연산

---

## 6. 병렬 최적화

1. **물리 속성**: 분할 방식·데이터 위치 정보 추가
2. **비용 모델**:

   * 자원 소비 vs. 응답 시간
   * 반복·중복 반영
3. **최적화 전략**:

   * 기존 순차 계획 최적화 후 병렬화
   * 물리 속성 통합 고려

---

## 7. 데이터 공존 & 뷰 유지보수

* **공존**: 공통 키 파티셔닝 or 작은 테이블 복제로 로컬 조인
* **다중 파티션 복제**: 색인처럼 여러 형태로 파티셔닝된 복제본 유지
* **병렬 뷰 유지**: exchange + 로컬 증분 갱신

---

## 8. 병렬 스트리밍 & MapReduce

1. **스트리밍 라우팅**: DAG or Pub/Sub(Kafka 토픽+파티션+컨슈머 그룹)
2. **연산 병렬화**:

   * 선택/투영: 독립 처리
   * 그룹/집계: 파티셔닝 + 사전 집계
   * 윈도잉: 그룹 속성만 파티셔닝하여 중첩 윈도 불필요
3. **장애 허용**: exactly-once via checkpoint, 재생, hot-spare replicas

---

## 9. 분산 질의 처리

1. **데이터 통합**:

   * 페더레이션: GAV / LAV 스키마 매핑 + 래퍼
   * 가상화: 스키마 통합 없이 단일 인터페이스 제공
2. **세미조인 전략**:

   ```text
   // r1 ⋈ r2 처리 시
   temp = Π조인 속성(r1)
   r2' = r2 ⋉ temp
   result = r1 ⋈ r2'
   ```

   * Bloom 필터로 over-approximation 가능
3. **분산 최적화**: 데이터 위치, exchange, semijoin 규칙, 사이트 제약 고려
4. **디렉토리 서비스**: 계층적·복제 DNS/LDAP을 통한 이름 해석 및 조회
