# 2. 관계형 표현식의 변환

## 1. 동치(Relational Equivalence)

- **동치식**: 모든 합법적 데이터베이스 인스턴스에서 **동일한 튜플 집합**(또는 중복 허용 시 동일한 multiset)을 반환하는 두 식
- **동치 규칙**: 특정 형태의 식을 **논리적으로 동일**한 다른 형태로 치환할 수 있다는 규칙 

> 옵티마이저는 **동치 규칙**을 활용해 비용이 더 낮은 식(실행 계획)으로 변환한다.


<br>

## 2. 변환 예시

- **변환 흐름**

  1. **조인 결합(6)** → (in ⋈ te) ⋈ Πcid,title(co)  
  2. **선택 푸시다운(7)** → σdept='Music'(in) ⋈ σyear=2017(te)  
  3. **투사 푸시다운(8)** → Πname,cid( … )로 중간 스키마 축소

  결과적으로 **중간 결과 크기**가 크게 줄어 든다.

<br>

## 3. 조인 순서(Join Ordering)

- 자연/세타 조인은 **교환·결합**이 가능 ➜ 다양한 조인 순서 생성
- 조인 순서는 **중간 릴레이션 크기**에 영향을 주어, 전체 비용에 큰 차이
  - 예: (σdept=instructor ⋈ teaches) ⋈ course 가 주어진 예에서 더 효율적

<br>

## 4. 동치식 열거(Enumeration)

1. 초기 식 E를 **EQ 집합**에 넣음  
2. 모든 식에 모든 규칙 적용 → 새 식 생성 → EQ에 추가  
3. **새 식이 더 이상 생기지 않을 때** 종료  
4. 각 식에 **비용 추정** 후 최소 비용 식 선택 (비용 기반 옵티마이저)

> 실제 구현은 **공유 서브트리** 구조, **휴리스틱 규칙**, **조인 순서 전용 탐색** 등으로 공간·시간을 줄인다.

<br>

---

<br>

# 3. 결과에 대한 통계 추정

## 1. 카탈로그 저장 통계

- **n<sub>r</sub>**: 릴레이션 r의 튜플 수
- **b<sub>r</sub>**: r이 차지하는 페이지(블록) 수
- **l<sub>r</sub>**: r 한 튜플 크기(바이트)
- **f<sub>r</sub>**: 한 페이지에 들어가는 r 튜플 수(Blocking factor)
- **V(A,r)**: r에서 **속성 A**의 서로 다른 값 개수

> 실제 DBMS는 **히스토그램**·**상위 n 빈발 값** 등 더 정교한 분포 정보를 함께 보관

<br>

## 2. 선택(Selection) 결과 크기 추정
- **A = a**  
  - 빈발 값 → 저장된 빈도 사용  
  - 그 외 → `n / V(A,r)` (균등 분포 가정)
- **A ≤ v,  A < v**  
  - 최소/최대값 이용, 균등 분포 가정  
  - 범위에 포함되는 비율 × n
- **복합 조건**  
  - **AND**: 각 조건 selectivity 곱  
  - **OR**: 1 − Π(1 − selectivity<sub>i</sub>)  
  - **NOT**: n − |σ<sub>θ</sub>(r)|

<br>

## 3. 조인(Join) 결과 크기 추정

- **카티전 곱 r × s**: `n_r · n_s`
- **자연조인** `r(A,… ) ⋈ s(A,… )`: `n_r · n_s / max(V(A,r), V(A,s))` (더 작은 값 선택)
- **A가 r의 키**: |r ⋈ s| ≤ n_s (외래 키 여부에 따라 정확)

> 두 테이블의 조인 속성에 동일한 구간 히스토그램이 있으면 **구간별** 위 공식을 적용 후 합산 → 더 정확

<br>

## 4. 기타 연산
| 연산 | 결과 크기 추정 |
| --- | --- |
| **Projection Π<sub>A</sub>(r)** | `V(A,r)` (중복 제거) |
| **Group-by γ<sub>G</sub>(r)** | `V(G,r)` |
| **집합 연산** |<div>r ∪ s : |r| + |s| (상한) <br>r ∩ s : min(|r|, |s|) (상한) <br>r − s : |r| (상한)</div>|
| **Outer Join** |<div>Left : |r ⋈ s| + |r| <br>Right : ↔ <br>Full : |r ⋈ s| + |r| + |s|</div> (상한) |

<br>

## 5. 중복 값 개수 추정
- **선택 결과**  
  - A 값이 단일 상수로 고정 → 1  
  - 범위/불균등 → `V(A,r) × selectivity`  
- **조인 결과**  
  - A가 r에만 ⇒ `min(V(A,r), |r ⋈ s|)` (s만인 경우 대칭)  
  - A가 양쪽 ⇒ 복합 공식 `min( V(A₁,r)·V(A₂,s), |r ⋈ s| )`

<br>

## 6. 통계 유지
- **무작위 샘플 + 히스토그램** : 정확도 대비 저장·계산 비용 절감  
- **주기적 ANALYZE / 자동 통계 갱신** : 시스템 부하 낮을 때 재계산  
- 정확도가 다소 떨어져도 **비용 기반 옵티마이저**는 대부분 적정(근사 최적) 계획을 선택

<br>

---

<br>

# 4. 평가 계획의 선택

## 1. 평가 계획(Evaluation Plan)의 의미
* **논리식** → 여러 **동치식** → 각 연산별 **구현 알고리즘(인덱스 스캔·해시 조인 …)** 을 지정한 것이 **평가 계획(physical plan)**  
* **비용 기반 옵티마이저**:  
  1. 동치 변환(16.2)으로 **대안 식** 생성  
  2. 각 식의 **연산별 알고리즘** 조합 → 다양한 계획  
  3. 16.3절 통계·15장 비용공식을 이용해 **총 비용** 추정  
  4. 최소 비용 계획 선택  

<br>

## 2. 조인 순서 최적화 (Cost‑Based Join Ordering)

- **폭발적 경우의 수**: n개의 릴레이션 ⇒ (2(n−1))!/(n−1)! 개의 순서
- **동적 계획법(DP)**: 부분집합 S ⊆ R 에 대해 **최적 부분계획** `bestplan[S]` 저장 (메모이제이션)
- **Interesting Order**: 정렬이 후속 조인/정렬에 “유용”하면 별도 상태로 저장 → 대부분 소수
- **왼쪽‑깊은(left‑deep) 제한(Heuristic)**: 외부 입력만 파이프라인 → 탐색 공간  ≈ O(n · 2ⁿ) (System R 방식)

<br>

## 3. 추가 최적화‑비용 절감 휴리스틱

- **선택‑투사 푸시다운**: σ, Π를 **가능한 한 일찍 적용**해 중간 릴레이션 축소 
- **카티전 제품 제거**: 분할 시 관련 조인 조건이 없는 경우 건너뜀 
- **예산 기반 탐색 중단**: 지금까지 찾은 최적 비용 이하로 **개선될 여지 적으면 탐색 중단** 
- **계획 캐싱(Plan Cache)**: 동일 구문 재실행 시 **처음 만든 물리 계획 재사용** 

<br>

## 4. 중첩 서브쿼리 최적화(Decorrelation)

- **EXISTS / IN**: `r ⋉ s` (세미조인) 으로 변환 → 랜덤 I/O 감소 
- **NOT EXISTS**: `r ▷ s` (안티‑세미조인) 
- **집계 서브쿼리**: 상수 비교 → 그룹화한 세미조인으로 변환<br>`1 < (select count(*) …)` ⇒ `r ⋉ (γ ID,count(*) as cnt (…))` 
- **불가능/고비용**: 다중 결과 스칼라·복잡한 상관관계 → **상관 평가(correlated evaluation)** 유지 

<br>

---

<br>

# 5. 실체화 뷰
- 뷰 유지(View Maintenance)
  - 즉시(Immediate) : 기본값, 트랜잭션 안에서 바로 갱신
  - 지연(Deferred) : 일정 시점·저부하 시간에 일괄 갱신
- 증분 유지(Incremental Maintenance) 핵심 패턴
  - `v = r ⋈ s`일 때
    - 삽입 `ir` → `v ← v ∪ (ir ⋈ s)`
    - 삭제 `dr` → `v ← v − (dr ⋈ s)`
  - 선택 `σθ(r)` → 삽입은 `σθ(ir)` 합치기, 삭제는 `σθ(dr)` 빼기
  - 투사/집계 → 중복 카운터(투사)·합/개수(집계) 등 보조 정보 필요
- 질의 최적화와 뷰 활용
  - 뷰로 대체: `r⋈s⋈t` → `(r⋈s_materialized) ⋈ t`
  - 뷰 풀어쓰기: 필터 조건·인덱스 활용 위해 `v` → 원래 정의로 역변환
- 뷰/인덱스 선택
  - 워크로드 기반 비용‑편익 분석 → DB 튜닝 도구(Oracle SQL Tuning Wizard, DB2 Design Advisor 등) 지원

<br>

---

<br>

# 6. 질의 최적화의 심화

- Top‑K Optimization
  - `LIMIT K` / 상위 K 요청 시 전체 정렬 대신
    - 파이프라인 계획으로 즉시 상위값 생성
    - 예상 상위 K 범위만 선택 후 필요 시 재실행
- Join Minimization
  - 외래키·NOT NULL 조건 이용 → 결과에 영향없는 조인 제거
- Update Optimization & Halloween Problem
  - 업데이트가 자신을 다시 읽어 무한 반복되지 않게
    - 인덱스 갱신을 별도 단계로 분리·배치 정렬 사용
    - 실행 계획에서 안전성 검사
- Multi‑Query Optimization / Shared Scan
  - 동일 릴레이션 스캔·부분식 공유하여 I/O 절감
  - 일괄 제출된 쿼리·복잡 서브쿼리에서 효과적
- Parametric Query Optimization (PQO)
  - 파라미터 없이 미리 여러 “최적” 계획 저장 → 실행 시 실제 값으로 가장 저렴한 계획 선택
- Adaptive Query Processing
  - 실행 도중 통계 모니터링 → 예상과 다르면 계획 전환
  - 예: Adaptive Join(입력 크기에 따라 NL ↔ Hash 선택)

