# 동시성 제어
트랜잭션의 핵심 속성 중 하나는 고립성  
여러 트랜잭션이 동시에 실행되면 고립성이 깨질 수 있다.  
이를 방지하기 위해 **동시성 제어(Concurrency Control)** 가 필요.  
동시성 제어는 트랜잭션 간 충돌을 관리하여 일관성을 유지함.  
주요 기법:
- Two-Phase Locking (2PL)
- Snapshot Isolation

## 18.1 잠금 기반의 규약
고립성 보장을 위해 트랙재션은 데이터에 동시 접근이 불가해야 한다.  
이를 위해 트랜잭션이 잠금(Lock)을 통해 데이터에 접근하도록 한다.

### 18.1 잠금
Lock은 트랜잭션이 데이터 항목에 접근할 때 다른 트랜잭션과의 충돌을 방지하기 위해 사용됨.

트랜잭션은 작업 전에 적절한 Lock을 요청해야 함.

- Lock의 두 가지 모드
  - Shared (S): 읽기 전용, 여러 트랜잭션 공유 가능
  - Exclusive (X): 읽고 쓰기 가능, 단독 접근만 허용

**호환성**
| 보유/요청 | S   | X   |
| --------- | --- | --- |
| S         | ✅   | ❌   |
| X         | ❌   | ❌   |

**주의사항**  
- 락을 너무 빨리 해제하면 다른 트랜잭션이 중간값을 읽게 됨 → 비일관성 발생
- 예시: 계좌 A와 B를 동시에 쓰는 도중 락을 풀면 잘못된 합계가 계산될 수 있음

### 18.1.2 잠금의 허용
**락 부여 조건**
- 충돌(lock conflict) 없으면 락 부여 가능
- BUT, 무작정 부여하면 starvation(기아 상태) 발생 가능

**기아 상태 예시**  
T2가 읽기 락(S) 보유 중 → T1이 쓰기 락(X) 요청 → 대기

그 사이 T3, T4가 계속 읽기 락 요청 → 허용됨 → T1은 계속 대기

결과: T1은 계속 기다리기만 함

**해결 방법**  
락 요청 시, 아래 조건 둘 다 만족해야 한다:
- 충돌하는 락 없음
- 나보다 먼저 기다리고 있는 트랜잭션 없음
  
먼저 요청한 트랜잭션이 우선, 나중 요청은 선행 요청 해소 후 가능

### 18.1.3 2단계 잠금 규약
트랜잭션이 락을 얻는 단계와 풀어주는 단계를 분리해서 직렬성을 보장한다.
- 증가 단계(Growing phase): 락을 얻을 수만 있음, 해제는 불가능
- 감소 단계(Shrinking phase): 락을 해제할 수만 있음, 새로운 락 얻을 수 없음  

락을 해제하고 감소 단계에서 절대로 락을 얻을 수 없다.

**특징**  
- 데드락이 발생가능
- 연쇄적인 롤백 발생 가능

**개선된 2PL 버전**
| 프로토콜                   | 설명                                                       |
| -------------------------- | ---------------------------------------------------------- |
| **엄격한 2단계 잠금 규약** | Exclusive 락은 **commit 시까지 유지** → Rollback 전파 방지 |
| **준엄한 2단계 잠금 규약** | **모든 락을 commit 시까지 유지** → 직렬 순서 = commit 순서 |

**Lock Conversion (잠금 변환)**
- Upgrade (S → X): Growing phase에서만 가능
- Downgrade (X → S): Shrinking phase에서만 가능  
  
→ 더 많은 동시성 확보 가능  
→ 단, 업그레이드는 다른 트랜잭션이 S 락 보유 중이면 대기해야 함

**자동 락 처리**
- read(Q) → lock-S(Q) 후 read(Q)
- write(Q) → 기존 S 락 있으면 upgrade(Q), 없으면 lock-X(Q)


## 18.1.4 잠금의 구현
**Lock Manager**는 트랜잭션의 락 요청을 처리하는 모듈이다.  
트랜잭션 → 락 요청 → Lock Manager → 허가 or 대기 or 롤백

**주요 역할**
- 락 요청 처리: 허용하거나 대기열에 추가
- 락 해제 시 처리: 다음 대기 중 트랜잭션에 락 넘겨줌
- 트랜잭션 중단 시 처리: 해당 트랜잭션의 모든 락 제거

**내부 구조: 잠금 테이블(Lock Table)**
- 해시 테이블 형태 (key = 데이터 항목 이름)

- 각 데이터 항목마다 요청 순서대로 연결 리스트

- 각 요청은 아래 정보 포함:
  - 트랜잭션 ID
  - 요청한 락 모드 (S 또는 X)
  - 현재 허용 여부

**락 부여 규칙**
1. 데이터에 아무 락도 없으면 → 즉시 허용
2. 이미 락 있음 → 기존 락들과 호환 가능하고, 먼저 대기 중인 요청이 모두 처리된 후 → 허용

**특징**
- 요청 순서를 보장하므로 기아상태 없음
- 데드락 발생 가능성은 있음

### 18.1.5 그래프 기반 규약
2단계 잠금 규약이 없이도 직렬성을 보장할 수 있는 프로토콜

**트리 규약 (Tree Protocol)**
데이터 항목의 접근 순서를 미리 안다고 가정하고 락 규칙을 설정함
- 전제:
  - 데이터 항목을 트리 구조(DAG)로 표현
  - 노드들 간 부분 순서(→) 를 따름  
    → A → B면 A를 먼저 락해야 B 락 가능

**트리 규약 규칙 (Exclusive Lock만 사용)**
1. 첫 락은 어디든 가능
2. 이후 락은 부모 노드 락이 잡혀 있어야 가능
3. 락 해제는 언제든 가능
4. 해제한 항목은 다시 락 불가

**장점**
- Conflict-serializability 보장
- 데드락 발생하지 않음

**단점**
- 필요한 데이터만 락해도 되지만  
  경로상 중간 노드까지도 락 걸어야 함 → 락 오버헤드 증가
- 트랜잭션의 접근 순서 사전 정보가 반드시 필요함
- Recoverability / Cascadelessness는 기본적으로 보장되지 않음  
→ 해결법: 락을 커밋 시점까지 유지하거나, commit dependency 사용

## 18.2 교착 상태 처리
**데드락**은 트랜잭션들이 서로의 락을 기다리며 영원히 멈춰있는 상태이다.

**해결 방법 2가지**
| 방법                                      | 설명                                               |
| ----------------------------------------- | -------------------------------------------------- |
| **1. 예방 (Prevention)**                  | **미리 차단**해서 deadlock이 생기지 않도록 함      |
| **2. 탐지 & 복구 (Detection & Recovery)** | **일단 발생하게 두고**, 나중에 찾아내서 **복구**함 |
> 예방은 **deadlock 발생 확률이 높은 시스템**에서 선호  
> 탐지+복구는 **낮은 빈도의 deadlock**에 더 효율적

### 18.2.1 교착 상태 예방

데드락이 **처음부터 발생하지 않도록** 트랜잭션 실행을 제한하는 방식.

#### 방법 1: 락 순서 강제

* 모든 락을 트랜잭션 시작 전에 한 번에 요청 (실제 적용 어려움)
* 또는 데이터 항목에 순서를 부여하고 **순서대로만 락 요청**

#### 방법 2: 타임스탬프 기반 롤백

* 트랜잭션 시작 시 고유한 **타임스탬프** 부여
* 충돌 시 **타임스탬프를 기준으로 대기 or 롤백 결정**

| 기법           | 방식         | 설명                                                           |
| -------------- | ------------ | -------------------------------------------------------------- |
| **Wait-Die**   | **비선점형** | 늙은 트랜잭션 → 대기<br>젊은 트랜잭션 → 롤백                   |
| **Wound-Wait** | **선점형**   | 늙은 트랜잭션 → 젊은 트랜잭션 롤백시킴<br>젊은 트랜잭션 → 대기 |

#### 방법 3: Lock Timeout

* 일정 시간 동안 락을 못 얻으면 **자동 롤백**
* 구현은 쉬움, 하지만 timeout 설정이 어려움
  → 너무 짧으면 불필요한 롤백, 너무 길면 대기 시간 증가
  → starvation 발생 가능성 있음

## 18.2.2 교착 상태 탐지와 복구

### 데드락 탐지 필요 조건

데드락 예방을 하지 않는 경우, 시스템은 주기적으로 **탐지 알고리즘**을 실행해야 함
→ 데드락 발생 시 감지 후 복구

### 1. 교착 상태 탐지

**대기 그래프 (Wait-For Graph)** 사용

* 노드: 트랜잭션
* 간선: `Ti → Tj` = Ti가 Tj가 가진 락을 기다리는 중

**데드락 조건**: 그래프에 **사이클(Cycle)** 이 존재
→ 사이클에 포함된 모든 트랜잭션이 교착 상태

**탐지 주기 결정 요소**

* 데드락 발생 빈도
* 데드락 시 영향을 받는 트랜잭션 수

> 자주 발생 → 탐지 알고리즘 자주 실행
> 거의 없음 → 느리게 실행해도 무방

### 2. 교착 상태로부터 복구

데드락 탐지 후 **롤백**을 통해 해소

#### 복구 절차

1. **희생자 선택**

   * 누굴 롤백시킬지 결정
   * 비용이 가장 적은 트랜잭션을 선택 (단, 기준은 다양함)

     * 실행된 시간
     * 사용 중인 자원 수
     * 남은 작업량
     * 연관된 트랜잭션 수

2. **롤백 수행**

   * **전체 롤백**: 트랜잭션 완전히 종료 후 재시작
   * **부분 롤백**: 문제 락 직전으로만 되돌림 → 성능 ↑

3. **기아 방지**

   * 동일 트랜잭션이 반복적으로 희생되지 않도록 **rollback 횟수 제한**
   * rollback 횟수도 비용 요소로 고려

## 18.3 다중 세분도
- 기본적으로 동시성 제어는 **개별 데이터 항목** 단위로 이루어짐
- 하지만 대량의 데이터를 접근하는 경우 **여러 개의 락을 획득**해야 하므로 비효율적

  - 예: 전체 릴레이션을 조회할 때 모든 튜플에 락을 걸면 락 테이블이 과도하게 커짐
- 반대로, 일부만 접근하는 트랜잭션에 전체 릴레이션 락을 요구하면 **동시성 저하**
  
**핵심 아이디어**

* **데이터를 계층 구조(Tree)** 로 표현하고, **다양한 수준(크기)** 에서 락을 획득

  * 예: 데이터베이스 → 영역(Area) → 파일(File) → 레코드(Record)

### 의도적 잠금 모드

하위 수준에 대한 잠금 의도를 **상위 노드에 표시**하여 락 충돌 여부를 빠르게 확인할 수 있게 함

| 잠금 모드                    | 의미                                 |
| ---------------------------- | ------------------------------------ |
| **IS (Intention Shared)**    | 하위 항목에 S 락 걸 예정             |
| **IX (Intention Exclusive)** | 하위 항목에 X 또는 S 락 걸 예정      |
| **SIX (Shared + IX)**        | 현재 노드는 S 락, 하위에는 X 락 예정 |


### 잠금 모드 간 호환성

| 보유/요청 | IS  | IX  | S   | SIX | X   |
| --------- | --- | --- | --- | --- | --- |
| IS        | ✔   | ✔   | ✔   | ✔   | ❌   |
| IX        | ✔   | ✔   | ❌   | ❌   | ❌   |
| S         | ✔   | ❌   | ✔   | ❌   | ❌   |
| SIX       | ✔   | ❌   | ❌   | ❌   | ❌   |
| X         | ❌   | ❌   | ❌   | ❌   | ❌   |


### 다중 세분도 잠금 규약

트랜잭션이 노드 Q에 락을 요청하려면 다음을 지켜야 함:

1. 루트부터 시작해 트리 하향식으로 락 획득
2. 하위 노드를 락 걸려면 상위 노드에 **의도적 락** 선행 필요
3. 이미 자식 노드에 락을 가진 경우, 부모 노드는 해제 불가
4. 락은 **위에서 아래로 얻고**, **아래에서 위로 해제**
5. 두 단계 락 규약(2PL)을 따름

### 장점

* **동시성 향상 + 락 수 감소** → 성능 최적화
* 다양한 규모의 트랜잭션 혼합 환경에 적합

  * 일부 튜플만 접근하는 짧은 트랜잭션
  * 전체 테이블을 스캔하는 보고서용 트랜잭션 등

### 잠금 확대

* 너무 많은 하위 수준 락이 잡혔을 때, 이를 **상위 수준 락 하나로 대체**

  * 예: 수십 개의 튜플 락 → 하나의 릴레이션 락으로 승격

## 18.4 삽입 연산, 삭제 연산, 술어 읽기
이전까지는 read, write만 고려 → 이미 존재하는 데이터에만 접근 가능  
현실에서는 다음 연산도 필요함:
- insert(Q): 데이터 항목 Q 생성
- delete(Q): 데이터 항목 Q 삭제

### 18.4.1 삭제
삭제 연산 `delete(Q)`는 기존의 `read(Q)`나 `write(Q)`보다 **더 많은 충돌**을 일으킬 수 있다.

### 삭제와의 충돌 사례

트랜잭션 `Ti`가 `delete(Q)`를 실행한 상황에서, 이어지는 `Tj`의 연산과의 관계:

| `Tj` 연산   | 충돌 여부 | 설명                                            |
| ----------- | --------- | ----------------------------------------------- |
| `read(Q)`   | ✅         | `delete(Q)`가 먼저면 `read(Q)`는 오류 발생      |
| `write(Q)`  | ✅         | `delete(Q)`가 먼저면 `write(Q)`도 오류 발생     |
| `delete(Q)` | ✅         | 둘 다 Q 삭제 시도 → 순서에 따라 둘 중 하나 오류 |
| `insert(Q)` | ✅         | Q 존재 여부에 따라 충돌 발생 가능               |

→ **삭제는 대부분의 연산과 충돌**  

* 삭제 시, 다음 조건을 확인함:

| 조건                      | 의미                        | 처리               |
| ------------------------- | --------------------------- | ------------------ |
| `TS(Ti) < R-timestamp(Q)` | 더 나중 트랜잭션이 Q를 읽음 | **Ti 롤백**        |
| `TS(Ti) < W-timestamp(Q)` | 더 나중 트랜잭션이 Q를 씀   | **Ti 롤백**        |
| 위 조건 없을 경우         | 충돌 없음                   | **삭제 수행** 가능 |

### 18.4.2 삽입
insert(Q)는 다음 연산들과 충돌한다
| 다른 연산   | 충돌 여부 | 이유                          |
| ----------- | --------- | ----------------------------- |
| `delete(Q)` | ✅ 충돌    | 삭제 대상과 삽입 대상이 동일  |
| `read(Q)`   | ✅ 충돌    | Q가 아직 없는데 읽으려는 시도 |
| `write(Q)`  | ✅ 충돌    | Q가 아직 없는데 쓰려는 시도   |
> 삽입 연산은 본질적으로 쓰기 연산과 같기 때문에, 충돌 처리와 동기화도 동일하게 적용된다.

### 18.4.3 술어 읽기와 유형 현상
#### 예시

* 트랜잭션 T30:

  ```sql
  SELECT COUNT(*) FROM instructor WHERE dept_name = 'Physics';
  ```

  → 조건에 맞는 튜플 개수를 조회 (조건 기반 읽기)

* 트랜잭션 T31:

  ```sql
  INSERT INTO instructor VALUES (11111, 'Feynman', 'Physics', 94000);
  ```

  → 튜플 삽입 (조건에 맞는 튜플 추가)

### 유령 현상(Phantom Phenomenon)

* T30이 특정 조건을 만족하는 튜플들을 읽고 있는 사이에
  T31이 조건을 만족하는 **새 튜플을 삽입**하면,
  **T30과 T31은 실제 같은 튜플을 공유하지 않지만 충돌 발생**

→ 이처럼 조건을 만족하는 **"새로운 튜플(유령)"** 때문에 생기는 충돌이 유형 현상

### 원인

조건 기반 쿼리는 **튜플이 아닌 “존재 여부 정보”를 읽음**
→ 실제로는 **튜플 자체가 아닌, 조건에 해당하는 "범위"나 인덱스 구조에 접근**
→ 일반적인 튜플 수준의 락으로는 충돌 감지가 안 됨

### 해결 방법 1: **인덱스 락 (Index Locking)**

팬텀 현상을 해결하면서도 **락 범위를 최소화**하려는 방법

#### 인덱스 락 규약

1. **모든 relation은 인덱스를 가져야 함**
2. 튜플 접근은 반드시 **인덱스를 통해서만 가능**
3. **조회 (T30 등)**: 해당 **인덱스 리프 노드**에 **공유락(S)** 획득
4. **삽입/삭제/갱신 (T31 등)**:

   * 영향을 받는 **리프 노드들에 배타락(X)** 획득
   * 삽입: 새 튜플의 search key가 들어갈 리프 노드에 X락
   * 삭제/업데이트: 기존 값과 변경될 값 모두에 대해 X락
5. 튜플 단위 락은 기존처럼 수행
6. **2단계 락 프로토콜(2PL)** 을 지켜야 함

→ 팬텀 현상을 **리프 노드 수준에서 충돌로 처리 가능**

### 해결 방법 2: **술어 잠금 (Predicate Locking)**

* T30이 조건(Predicate)에 대해 **공유락(S)** 획득
* 삽입/삭제/업데이트가 **조건을 만족하면 충돌로 간주**

→ 이론상 가장 정확하지만,
**구현 복잡도 높고 성능 저하** → **실제 DB에서는 잘 사용 안 함**

## 18.5 타임스탬프 기반 규약
락 기반 프로토콜은 실행 중인 트랜잭션의 락 요청 순서를 통해 직렬 순서를 정함.  
타임스탬프 기반 프로토콜은 아예 트랜잭션이 시작될 때 고유한 타임스탬프를 부여하여  
선택된 순서에 따라 직렬성(serializability)을 보장함.

### 18.5.1 타임스탬프
#### 트랜잭션별 고유한 타임스탬프 부여: `TS(Ti)`

* Ti가 먼저 시작됐으면 `TS(Ti) < TS(Tj)`
* 시스템은 이 순서대로 직렬 스케줄처럼 보장해야 함

#### 타임스탬프 부여 방식

| 방법        | 설명                                        |
| ----------- | ------------------------------------------- |
| 시스템 시계 | 트랜잭션 시작 시점의 **현재 시간** 사용     |
| 논리 카운터 | 새 트랜잭션마다 **1씩 증가**한 정수 값 부여 |

#### 데이터 항목별 메타정보 (각 Q에 대해 관리)

| 메타데이터       | 의미                                                |
| ---------------- | --------------------------------------------------- |
| `W-timestamp(Q)` | 마지막으로 Q에 **성공적으로 write한 트랜잭션의 TS** |
| `R-timestamp(Q)` | 마지막으로 Q에 **성공적으로 read한 트랜잭션의 TS**  |

→ 트랜잭션의 `read(Q)` / `write(Q)` 수행 시 이 정보로 충돌 여부 판단

## 18.5.2 타임스탬프 순서 규약
### 연산 처리 규칙

#### `read(Q)` 처리

* `TS(Ti) < W-timestamp(Q)`
  → **Ti는 덮어쓰기 이전 값**을 읽으려 함 → **읽기 거부 & 롤백**
* `TS(Ti) ≥ W-timestamp(Q)`
  → 읽기 허용 & `R-timestamp(Q)` := max(기존, TS(Ti))

#### `write(Q)` 처리

* `TS(Ti) < R-timestamp(Q)`
  → 이미 다른 트랜잭션이 읽은 값을 덮으려 함 → **쓰기 거부 & 롤백**
* `TS(Ti) < W-timestamp(Q)`
  → 오래된 트랜잭션이 값을 덮으려 함 → **쓰기 거부 & 롤백**
* 위 두 조건 없으면 → 쓰기 허용 & `W-timestamp(Q)` := TS(Ti)

> 연산 거부 시 Ti는 **새로운 타임스탬프로 재시작**

### 특징

| 항목                 | 설명                                                           |
| -------------------- | -------------------------------------------------------------- |
| **직렬성 보장**      | 모든 충돌을 타임스탬프 순서로 처리 → conflict-serializable     |
| **데드락 없음**      | 트랜잭션 간 대기 없이 바로 판단함                              |
| **기아(starvation)** | 가능. 짧은 트랜잭션이 길고 늦은 트랜잭션을 계속 방해할 수 있음 |
| **복구 가능성 문제** | 기본 프로토콜은 **recoverable하지 않음** → 보완 필요           |

### Recoverability 보장 방법

1. **Atomic Write**

   * 트랜잭션이 끝날 때 **한꺼번에 쓰기** 수행
   * 쓰기 중에는 해당 데이터에 접근 불가

2. **제한적 락 사용**

   * 커밋되지 않은 값은 **읽기 지연**

3. **Commit Dependency**

   * 읽은 값이 커밋되지 않았다면 **기다렸다가 커밋 후에 커밋**

### 유령 현상 방지

* 기본적으로는 **튜플 단위만 고려** → 팬텀 문제 발생 가능
* 해결 방법: **인덱스 노드나 메타데이터에도 타임스탬프 적용**
* 인덱스 노드도 **데이터 항목처럼** 관리하여 타임스탬프 비교 수행
  → 조건 기반 읽기에서도 **직렬성 보장**

### 18.5.3 토마스의 쓰기 규칙

**기존 타임스탬프 순서 규약을 개선해 더 많은 동시성을 허용**

> 불필요한 write를 무시함으로써 **롤백 횟수를 줄임**
> → 일부 **비충돌 직렬 불가능 스케줄도 허용** (View-serializable 스케줄까지 수용)

#### `write(Q)` 처리 규칙 (수정된 타임스탬프 프로토콜)

| 조건                      | 처리      | 의미                                                 |
| ------------------------- | --------- | ---------------------------------------------------- |
| `TS(Ti) < R-timestamp(Q)` | 롤백      | 예전에 읽힌 값 덮으려 함 → 타임스탬프 위반           |
| `TS(Ti) < W-timestamp(Q)` | **무시**  | 이미 더 최신 트랜잭션이 write함 → 구버전 덮기 무의미 |
| 그 외                     | 정상 수행 | write 수행, `W-timestamp(Q)` := TS(Ti)               |

---

#### 특징 요약

| 항목                         | 설명                                                                                |
| ---------------------------- | ----------------------------------------------------------------------------------- |
| ✅ 동시성 증가                | 불필요한 write를 무시하므로 불필요한 롤백 방지                                      |
| ✅ View-serializable 허용     | conflict-serializable은 아니더라도 논리적으로 같은 결과를 보장하는 스케줄 허용      |
| ❌ Conflict-serializable 아님 | → 기존 2PL이나 일반 Timestamp Protocol로는 허용되지 않던 스케줄도 허용              |
| 💡 활용 예시                  | Schedule: T27 (old) → T28 (new) → T27의 write는 무시 가능 → \<T27, T28> View와 동일 |


### 18.6 검증 기반 규약
> **락 없이** 동시성 제어를 수행하는 방식
> 대부분의 트랜잭션이 충돌 없이 잘 수행되는 **읽기 위주 환경**에 적합
> "일단 실행, 나중에 검증" → **낙관적(Optimistic) 동시성 제어**

### 트랜잭션 수행 단계 (총 3단계)

| 단계             | 설명                                                                          |
| ---------------- | ----------------------------------------------------------------------------- |
| **1. 읽기 단계** | 실제 DB는 건드리지 않고, **읽기 + 쓰기 결과는 로컬 변수에 저장**              |
| **2. 검증 단계** | 직렬성을 보장할 수 있는지 확인 (Validation Test)                              |
| **3. 쓰기 단계** | 검증 통과 시, 로컬 변수의 내용을 **실제 DB에 반영(write)** (읽기 전용은 생략) |

### 트랜잭션 타임스탬프

각 트랜잭션 Ti에 대해 3가지 타임스탬프를 관리:

| 타임스탬프         | 의미                                     |
| ------------------ | ---------------------------------------- |
| `StartTS(Ti)`      | 읽기 단계 시작 시간                      |
| `ValidationTS(Ti)` | 검증 단계 시작 시간 (→ 이게 TS로 사용됨) |
| `FinishTS(Ti)`     | 쓰기 단계 완료 시간                      |

→ 직렬화 순서는 `ValidationTS` 기준으로 정함

### 검증 조건

트랜잭션 `Ti`가 검증을 통과하려면, **모든 Tk (TS(Tk) < TS(Ti))** 에 대해:

1. `FinishTS(Tk) < StartTS(Ti)`
   → Tk가 Ti 시작 전에 완전히 끝남 → **충돌 없음**

**또는**

2. `Tk.writeSet ∩ Ti.readSet == ∅` 이고
   `StartTS(Ti) < FinishTS(Tk) < ValidationTS(Ti)`
   → 읽은 것과 쓴 것이 안 겹치고, Ti가 검증 시작할 때 Tk의 쓰기까지 끝난 상태
   → **충돌 없음**

### 타임스탬프 대안

* 기본: `TS(Ti) = ValidationTS(Ti)` 사용
* 대안: `TS(Ti) = StartTS(Ti)`
  → 단, 이 경우 더 오래된 트랜잭션이 끝날 때까지 기다려야 할 수 있어 비효율


## 18.7 다중 버전 기법
하나의 데이터 항목에 여러 버전(복사본) 을 유지해서  
읽기와 쓰기의 충돌 없이 동시성 보장  
기존 방식과 달리 읽기 연산 거부나 트랜잭션 중단 없이도 직렬성 유지 가능

### 18.7.1 다중 버전 타임스탬프 순서
> **쓰기 충돌을 줄이고 읽기 연산을 실패 없이 처리**할 수 있도록  
> 기존 **타임스탬프 기반 프로토콜을 다중 버전 방식으로 확장**

### 구조

#### 트랜잭션마다:

* **고유 타임스탬프 TS(Ti)** 부여 (트랜잭션 시작 시)

#### 데이터 항목 Q:

* 여러 버전 존재: `Q1, Q2, ..., Qm`
* 각 버전 `Qk`는 다음 필드 포함:

  | 필드              | 설명                                        |
  | ----------------- | ------------------------------------------- |
  | `Content`         | Qk의 실제 값                                |
  | `W-timestamp(Qk)` | Qk를 만든 트랜잭션의 타임스탬프             |
  | `R-timestamp(Qk)` | Qk를 읽은 트랜잭션 중 가장 큰 타임스탬프 값 |

### 연산 처리 규칙

#### 1. `read(Q)` 처리

* Ti는 **TS(Ti) ≤ W-timestamp** 인 버전 중 가장 최신 버전 Qk를 읽음
* **Qk의 content 반환**
* 그리고 `TS(Ti) > R-timestamp(Qk)`이면 → `R-timestamp(Qk)`를 갱신

#### 2. `write(Q)` 처리

* Ti는 위와 같은 조건으로 버전 Qk 찾음
* 아래 조건 판단:

| 조건                       | 처리                                       |
| -------------------------- | ------------------------------------------ |
| `TS(Ti) < R-timestamp(Qk)` | **Ti 롤백** (읽힌 적 있는 값 위에 쓰려 함) |
| `TS(Ti) = W-timestamp(Qk)` | **Qk 덮어쓰기 (overwrite)**                |
| `TS(Ti) > R-timestamp(Qk)` | **새 버전 생성 (Qnew)**                    |

### 유효 구간 (Valid Interval)

* 버전 Qk의 `W-timestamp = t`
* 그 다음 버전의 `W-timestamp = s`이면:
  → Qk의 유효 구간: `[t, s)`
* → **TS가 이 구간에 속하는 트랜잭션은 Qk 읽음**

### 오래된 버전 삭제 조건

* Qk, Qj가 있고 둘 다 `W-timestamp < 가장 오래된 트랜잭션의 TS`
* 이 경우 **더 오래된 버전 삭제 가능**

### 장점

| 항목            | 설명                                   |
| --------------- | -------------------------------------- |
| **읽기 효율**   | **읽기는 항상 성공**, 지연/롤백 없음   |
| **고성능**      | 읽기 많은 시스템에 유리                |
| **동시성 향상** | 충돌 없이 다수 트랜잭션 병행 처리 가능 |

### 단점

| 문제                                               | 설명                                                 |
| -------------------------------------------------- | ---------------------------------------------------- |
| **읽기 → 쓰기 갱신 발생**                          | R-timestamp 갱신 위해 디스크 I/O 2번 발생 가능       |
| **충돌 해결 방식**                                 | wait 없이 무조건 rollback → **비용 큼**              |
| **복구성 없음**                                    | 기본 형태는 **recoverable / cascadeless** 보장 안 됨 |
| → **timestamp 방식처럼 확장하여 복구성 보완 가능** |                                                      |


## 18.7.2 다중 버전 2단계 잠금
멀티버전 접근의 **비차단 읽기 장점** + 2PL의 **직렬성과 복구성 보장**을 결합

### 트랜잭션 분류

| 종류              | 특징                                                                         |
| ----------------- | ---------------------------------------------------------------------------- |
| **읽기 전용**     | - 실행 전 `ts-counter` 값을 읽어 타임스탬프로 사용<br>- 멀티버전 읽기만 수행 |
| **갱신 트랜잭션** | - **2단계 잠금(2PL)** 사용<br>- 모든 락은 **커밋까지 유지**                  |


### 읽기 전용 트랜잭션

* 실행 시작 시 `ts-counter` 값을 타임스탬프로 저장
* 읽기 시 → **자신의 타임스탬프 이하에서 가장 최근 버전** 읽음
* 락을 **획득하지 않음** → 비차단 읽기 가능

### 갱신 트랜잭션

1. **읽기:** 해당 항목에 **공유락(S)** 획득 후 최신 버전 읽기
2. **쓰기:** 해당 항목에 **배타락(X)** 획득 후 **새 버전 생성**

   * 새 버전의 타임스탬프는 일단 `∞`로 설정

### 커밋 처리

* **한 번에 하나의 갱신 트랜잭션만 커밋 가능**
* 커밋 시:

  1. 새 버전들의 타임스탬프 := `ts-counter + 1`
  2. `ts-counter` := `ts-counter + 1`
  3. 커밋 완료

### 직렬성 보장 방식

* 읽기 전용 트랜잭션은 `ts-counter` 기반으로 보기 때문에,

  * 커밋된 갱신 트랜잭션 이후에 시작한 읽기 전용 트랜잭션만 변경 내용을 봄
* 결과적으로 **읽기 전용 트랜잭션은 항상 과거 일관된 상태를 읽음**
* → **직렬성, 복구성, cascadelessness 보장**

### 버전 삭제 규칙

* 버전 Qk와 Qj가 있고
* 둘 다 **가장 오래된 읽기 전용 트랜잭션의 타임스탬프보다 작거나 같으면**
* 더 오래된 버전은 **삭제 가능**

## 18.8 스냅샷 고립
**스냅샷 고립성**은 PostgreSQL, Oracle, SQL Server 등에서 널리 쓰이는 **비관적 락 없이 동시성 제어**하는 방식이다.

### 기본 개념

* 트랜잭션은 **시작 시점의 DB 상태(스냅샷)** 를 기반으로 작업
* 스냅샷에는 **커밋된 트랜잭션의 결과만 포함**
* 트랜잭션은 **독립된 복사본에서 수행**됨 → 다른 트랜잭션과 충돌 없이 읽기 가능

### 읽기 전용 트랜잭션

* 항상 **즉시 실행 가능**
* **락 없음**, **대기 없음**, **롤백 없음**
* **최적의 성능** 제공

### 갱신 트랜잭션 (업데이트 포함)

* 업데이트는 트랜잭션의 **로컬 작업 공간**에서 일시적으로 저장
* **커밋 시점에 유효성 검사(validation)** 진행

  * 다른 트랜잭션과 충돌 발생 여부 판단

### 커밋 시 처리 방식

* 커밋 허용 시 → **업데이트 내용이 원자적으로 반영됨**

  * 어떤 다른 트랜잭션이 스냅샷을 생성할 때, T의 모든 변경사항을 **한꺼번에 포함하거나 제외**
  * → **일관된 스냅샷 보장**

## 18.8.1 스냅샷 고립에서 다중 버전

**스냅샷 고립성(Snapshot Isolation)** 은 **멀티버전 데이터 관리** 기반으로 동작한다.

### 트랜잭션 타임스탬프

트랜잭션 Ti는 두 개의 타임스탬프를 가진다:

| 타임스탬프     | 의미                            |
| -------------- | ------------------------------- |
| `StartTS(Ti)`  | Ti가 **시작한 시점**            |
| `CommitTS(Ti)` | Ti가 **커밋(검증 요청)한 시점** |

→ 보통 **카운터 기반**으로 순서 보장 (실시간 시계도 가능하지만 중복 없어야 함)

### 버전 생성

* 데이터 항목을 업데이트할 때마다 **새 버전 생성**
* 버전의 타임스탬프 = **CommitTS(Ti)**
  → 즉, **커밋이 승인된 이후에만 DB에 반영**

### 읽기 동작

* Ti는 **자신이 시작한 시점(`StartTS`) 이전**에 커밋된 최신 버전만 읽을 수 있음
  → 즉, **자신보다 나중에 커밋된 트랜잭션의 변경은 보이지 않음**
* 결과적으로, Ti는 **시작 시점 기준의 스냅샷을 보는 것과 동일**

> 실제 구현에서는 버전마다 **유효 구간(StartTS \~ 다음 CommitTS)** 을 관리해  
> 빠르게 유효 버전을 찾도록 최적화하는 경우도 있음.

### 18.8.2 갱신 트랜잭션을 위한 검증 단계
다음은 **18.8.2 Validation Steps for Update Transactions**에 대한 간단 명료한 요약입니다:

---

## 18.8.2 업데이트 트랜잭션의 검증 단계

**예시**:
스냅샷 격리에서는 트랜잭션들이 서로 **고립된 스냅샷**을 사용 → 서로의 수정사항을 모름
→ 동시에 같은 항목을 수정하면 **lost update(갱신 손실)** 발생 가능
→ 이를 방지하려면 **커밋 시점 검증(validation)** 필요

### 동시성 판단 기준

트랜잭션 `Tj`가 `Ti`와 **동시성(concurrent)** 이라면 아래 조건 중 하나 만족:

* `StartTS(Tj) ≤ StartTS(Ti) ≤ CommitTS(Tj)`
* `StartTS(Ti) ≤ StartTS(Tj) ≤ CommitTS(Ti)`

---

### 검증 방식 1: **첫 번째 커밋이 승리 (First Committer Wins)**

**커밋 시점에 아래 조건 검사**:

* `Ti`가 쓰려는 데이터 항목 중에,
  `StartTS(Ti)` \~ `CommitTS(Ti)` 사이에 **이미 커밋된 다른 버전**이 있는지 검사

→ 있다면 **Ti는 abort**

→ 없다면 **Ti는 커밋**

> 먼저 커밋 시도한 트랜잭션이 **승자**가 됨

### 검증 방식 2: **첫 번째 갱신이 승리(First Updater Wins)**

**쓰기 시도 시점에 락을 통해 충돌 방지**:

* `Ti`가 데이터 항목에 쓰기 시도 → **락 요청**

* 락이 없다면 획득 → 다음 검사:

  * 만약 **동시성 트랜잭션이 이미 업데이트**했다면 → **Ti는 abort**
  * 아니라면 → 계속 실행 가능

* 락이 이미 있으면 대기:

  * **Tj가 abort**하면 → 락 획득 후 검사
  * **Tj가 커밋**하면 → **Ti는 abort**

> 먼저 락 잡은 트랜잭션이 **승자**

## 18.9 실제 사용되는 약한 수준의 일관성

* SQL 표준 격리 수준(Serializable, Repeatable Read, Read Committed, Read Uncommitted) 외에도,   
  과거에는 **약한 일관성 수준을 비표준 용어**로 정의한 경우도 있었음.
* 이 절에서는 **예전의 약한 일관성 수준 용어**와 **SQL 표준과의 관계**를 간단히 정리하고,
* **사용자 상호작용이 포함된 트랜잭션**의 동시성 제어 문제를 다룸.
  * (예: 사용자 입력을 기다리는 트랜잭션은 실행 중 대기하면서 데이터 락을 장시간 보유할 수 있음)

## 18.9.1 수준-2 일관성

* **목표**: *Cascading abort* 방지, 하지만 직렬성(serializability)은 보장하지 않음.
* **규칙**:

  * S-lock: 언제든 해제 가능
  * X-lock: **커밋 or 롤백 전까지 유지**
* **결과**:

  * 읽기 결과가 반복되지 않을 수 있음 (repeatable read 보장 X)
  * → SQL의 **Read Committed 수준**에 해당
* **문제**: 인덱스 스캔 중 삽입/삭제로 인해 **중복 조회 또는 누락** 발생 가능

---

## 18.9.2 커서 안정성

* **용도**: 커서를 이용해 튜플을 순차적으로 처리할 때 사용
* **규칙**:

  * 현재 커서가 가리키는 튜플만 S-lock 유지
  * 수정된 튜플은 X-lock → 커밋까지 유지
* **장점**: 동시성 향상
* **단점**: 직렬성 보장 X → 애플리케이션이 데이터 일관성 직접 관리해야 함

## 18.9.3 사용자 상호작용에 대한 동시성 제어

* **문제**: 사용자 입력을 기다리는 동안 락 유지 시, **오랜 시간 동안 리소스 점유** 발생

* **대안 1**: **Snapshot Isolation**

  * 사용자 간 충돌이 없으면 트랜잭션 유지
  * 단, 커밋되지 않은 트랜잭션 정보를 오래 보관해야 하는 단점

* **대안 2**: 트랜잭션을 **두 개로 나누기**

  * ① 사용자 입력 전 (seat 조회)
  * ② 사용자 입력 후 (seat 예약)
  * → 두 번째 트랜잭션에서 **seat 변경 여부 확인** 필요

* **대안 3**: **버전 번호 기반 검증**

  * 각 튜플에 버전 번호 추가
  * 트랜잭션이 읽을 때 버전 저장 → 커밋 시 버전 비교

    * 버전 동일 → 업데이트 허용 + 버전 증가
    * 다르면 롤백
  * → **Snapshot Isolation과 유사**, 하지만 **읽기 검증은 하지 않음**

* **주의**: 직렬성 보장 X → 개발자가 애플리케이션 논리로 일관성 보장 필요

## 18.10 동시성 제어의 최신 동향
* **인덱스 전용 동시성 제어**

  * 일반적인 2PL 대신 **인덱스에 특화된 동시성 제어 기법** 사용
  * → **더 높은 동시성** 가능

* **메인 메모리 데이터베이스 환경**

  * 인덱스 동시성 제어 **간소화 가능**
  * 락/검증 등의 비용이 **병목**이 되기 쉬움
  * → **Latch-free 구조** 등으로 오버헤드 최소화

* **연산 기반 동시성 제어**

  * 단순 읽기/쓰기 대신 `increment` 같은 **고수준 연산 단위**로 충돌 감지

* **실시간/제한시간 기반 트랜잭션**

  * **완료 시간 보장**이 필요한 애플리케이션을 위한 **특수 기법** 존재

### 18.10.1 온라인 인덱스 생성
* 대용량 데이터에서 인덱스 생성은 **오래 걸림 → 시스템 중단 문제 발생**

* **온라인 인덱스 생성**: 인덱스 생성 중에도 **릴레이션 업데이트 허용**

  1. 스냅샷 기반으로 인덱스 생성 시작, 이후 변경 로그 기록
  2. 스냅샷 인덱스 생성 완료 후, 로그를 통해 누락된 업데이트 반영
  3. **마지막으로 shared lock** 걸고 남은 업데이트 적용 → 일관성 보장 후 인덱스 활성화

* **Materialized view 생성**이나 **제약 조건 추가(예: Primary Key)** 에도 유사한 기법 사용 가능

  * 제약 조건 추가 시에도 스냅샷 기반 검사 → 마지막에 shared lock으로 남은 변경 검증 후 반영

### 18.10.2 인덱스 구조에서의 동시성 제어

* 인덱스에 2PL 적용 시 **락 충돌 많아 동시성 저하** → **특수 기법 사용**

### 크래빙 규약

* 루트에서 리프까지 **shared lock 후 자식 락 걸고 부모 락 해제**
* 삽입/삭제 시 리프에 exclusive lock, 필요 시 부모/형제 노드도 락
* **부분 잠금만 유지하므로 동시성 ↑**, deadlock 시 search 재시작

### B-link 트리 잠금 규약

* **노드에 오른쪽 형제 포인터 추가**
* 한 번에 한 노드만 락 → deadlock 회피, 동시성 더 높음
* split/merge 중에도 구조 변경 탐지 가능

### 유령 현상 방지: **Next-Key Locking**

* **범위 조회 시 "다음 키"도 같이 락**
* 삽입/삭제도 "다음 키" 포함하여 락 → 충돌 감지 강화

### 18.10.3 메인 메모리 DB에서의 동시성 제어

* 디스크 I/O가 없는 **메모리 DB**에서는 락 비용이 성능 병목
  → **간단한 구조** 또는 **락 없는(latch-free) 구현**이 효과적

### Latch-Free 자료구조

* **CAS (Compare-And-Swap)** 명령어로 삽입/삭제 구현 가능

  * 예: Linked List 삽입 시 `head`를 CAS로 원자적 변경
  * 여러 스레드가 동시에 작업해도 충돌 없이 처리 가능

### ABA 문제 (삭제 오류)

* 값이 같아도 상태가 다를 수 있음 → **버전 번호(counter)** 함께 관리 필요
* → **128비트 CAS**로 포인터 + 버전 함께 비교

### 실무 적용

* 직접 구현은 위험 → **표준 라이브러리 사용 권장**

  * 예: Java `ConcurrentLinkedQueue`, C++ `Boost`

### 18.10.4 장기 실행 트랜잭션

* **사람과 상호작용**하는 트랜잭션은 시스템 입장에서 **장시간**이 소요됨

* 주요 특징:

  * 응답 전까지 오랜 시간 필요 → **비효율/비예측성**
  * 중간 결과(미커밋 데이터)를 사용자에게 **노출**
  * **서브태스크 단위 취소** 가능해야 함
  * **시스템 장애 후 복구**는 필수
  * 사용자 관점에서 **빠른 응답시간/예측 가능성** 중요

* 해결책:

  * **스냅샷 격리** 또는
  * **읽기 검증 없는 낙관적 동시성 제어(Optimistic CC)** 사용 → 직렬성 보장은 안 되지만 실용적

### 18.10.5 다양한 연산을 이용하는 동시성 제어

* **직렬성이 없어도 정합성 유지 가능**한 경우 있음 (예: A+B 유지)
* 핵심: 정합성 보장은 **데이터 제약 조건**과 **연산 의미**에 따라 달라짐

### 예: Materialized View 갱신

* 뷰에 **누적합 갱신**: 각 트랜잭션이 `increment(v, n)` 수행

  * 락 없이 순차적으로만 실행되면 충돌 없음
  * 롤백 시: `increment(v, -n)` 으로 보상
* `increment`는 자기끼리 호환되나, **읽기 연산과는 충돌** → 별도 락 모드 필요

| 보유/요청 | S   | X   | I (Increment) |
| --------- | --- | --- | ------------- |
| S         | ✅   | ❌   | ❌             |
| X         | ❌   | ❌   | ❌             |
| I         | ❌   | ❌   | ✅             |

### 예: 조건부 증가 `increment_conditional(v, n)`

* 티켓 3장 구매 시 `increment_conditional(tickets, -3)`
* 결과가 0 이상이면 성공, 아니면 실패 반환
* 단, 서로 겹치지 않게 실행 순서에 따라 결과가 달라질 수 있음 → **완전한 직렬성 보장 안 됨**, 실용성 우선

### 18.10.6 실시간 트랜잭션 시스템

* **데드라인(마감 시간)** 이 존재하는 시스템 (예: 교통 제어, 공장 제어)

  * **Hard**: 초과 시 치명적 (시스템 크래시)
  * **Firm**: 초과 시 무의미
  * **Soft**: 초과할수록 가치 감소

### 특징

* 트랜잭션이 대기하면 **데드라인 초과 가능**
* 경우에 따라 **락 보유 트랜잭션을 선점(preemption)**하여 데드라인 있는 트랜잭션 우선 실행
* **롤백 vs 대기** 선택이 어려움 → 예측 불가

### 실시간 시스템에서는:

* **주기억장치 DB** 선호 (디스크 지연 없음)
* **낙관적 기법(Optimistic CC)** 이 **락 기반보다 데드라인 위반 적음**
