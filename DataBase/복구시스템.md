# 동시성 제어
* 복구 시스템은 트랜잭션의 원자성(Atomicity) 과 지속성(Durability) 을 보장하기 위해, 장애 발생 시 데이터베이스를 장애 이전의 일관된 상태로 되돌리는 작업을 수행한다.
* 장애는 다양한 유형으로 발생할 수 있으며, 복구 시스템은 이에 따라 적절한 복구 알고리즘을 제공해야 한다.


## 19.1 장애의 분류
데이터베이스에서 장애 유형을 다음과 같이 분류한다.

| 장애 유형         | 설명                                                          | 예시                                          |
| ----------------- | ------------------------------------------------------------- | --------------------------------------------- |
| **트랜잭션 실패** | 트랜잭션이 정상 실행을 중지하는 상황                          | 논리 오류 (잘못된 입력), 시스템 오류 (데드락) |
| **시스템 장애**   | 하드웨어/소프트웨어 문제로 인해 휘발성 저장장치의 데이터 손실 | 전원 중단, 시스템 버그                        |
| **디스크 고장**   | 디스크 자체의 물리적 손상으로 데이터 손실                     | 디스크 헤드 크래시, 데이터 전송 오류          |

* 이러한 장애 유형을 기반으로 적절한 복구 전략을 수립해야 한다.

## 19.2 저장장치

데이터베이스에서 사용하는 저장장치는 크게 세 가지 유형으로 나눌 수 있다.

* **휘발성 저장장치(Volatile Storage)**: 메모리(RAM) 등으로, 전원이 꺼지면 데이터가 사라짐
* **비휘발성 저장장치(Non-Volatile Storage)**: 디스크나 SSD로, 전원이 꺼져도 데이터 유지
* **안정적 저장장치(Stable Storage)**: 여러 개의 독립적인 비휘발성 장치에 데이터를 중복 저장하여 매우 높은 신뢰성 제공

### 19.2.1 안정 저장 장치의 구현

안정적 저장장치를 구현하는 방법은 다음과 같다.

* **미러링(Mirroring)**: 동일한 데이터를 두 개 이상의 디스크에 복제하여 하나의 디스크가 고장 나도 데이터가 안전하도록 구현.
* **원격 백업(Remote Backup)**: 데이터가 기록될 때마다 로컬 디스크와 동시에 원격지의 디스크에도 데이터를 기록하여 재해로부터 보호.

**안정적 저장장치 쓰기 프로세스**

1. 첫 번째 물리적 블록에 데이터를 쓴다.
2. 성공하면 두 번째 물리적 블록에 같은 데이터를 쓴다.
3. 두 번째 쓰기도 성공해야만 쓰기 연산이 완료된다.

> 만약 실패가 발생하면, 두 블록의 데이터를 비교하여 일관성 있는 데이터로 복구한다.

### 19.2.2 데이터 접근

데이터베이스 내의 데이터 접근은 다음 개념으로 설명할 수 있다.

* 데이터베이스는 **물리적 블록** 단위로 디스크에 저장된다.
* 데이터를 메모리에서 임시로 유지하는 장소를 **디스크 버퍼(Disk Buffer)** 라고 부른다.

**주요 연산:**

* **input(B)**: 디스크에서 메모리로 블록 B를 읽어옴
* **output(B)**: 메모리에서 디스크로 블록 B를 기록

**트랜잭션 내의 데이터 읽기/쓰기 연산 과정**

| 연산         | 과정                                                         |
| ------------ | ------------------------------------------------------------ |
| **read(X)**  | 블록이 메모리에 없으면 input, 메모리에서 로컬 변수로 값 복사 |
| **write(X)** | 블록이 메모리에 없으면 input, 로컬 변수 값을 메모리에 반영   |

* 트랜잭션의 수정 결과가 반드시 즉시 디스크에 기록될 필요는 없으며, 디스크 기록은 나중에 지연될 수 있음 (no-force 정책).
* 반면, 수정된 블록을 다른 용도로 메모리에서 제거할 때는 디스크에 기록이 필요할 수 있음 (steal 정책).

## 19.3 복구와 원자성

* **복구 시스템**의 가장 중요한 목표 중 하나는 **트랜잭션의 원자성**을 보장하는 것이다.

  * 즉, 트랜잭션은 **모든 연산이 반영되거나, 전혀 반영되지 않아야 한다**(All-or-Nothing).

트랜잭션이 여러 데이터 항목을 변경하는 동안 중간에 실패하면, 일부 데이터만 변경된 상태로 남게 된다.
이 문제를 해결하기 위해 DBMS는 **로그(Log)** 를 활용하여 변경 이력을 기록하고, 장애 시 이를 통해 원자성을 보장한다.


### 19.3.1 로그 레코드

로그는 데이터베이스의 모든 변경사항을 기록하는 구조로, 장애 후 복구 시 사용된다.

**로그 레코드의 주요 형식**

| 로그 레코드 유형 | 형태                            | 의미                                 |
| ---------------- | ------------------------------- | ------------------------------------ |
| **Update**       | `<Ti, X, old_value, new_value>` | Ti가 X를 수정 (이전 값과 새 값 기록) |
| **Start**        | `<Ti start>`                    | 트랜잭션 Ti 시작                     |
| **Commit**       | `<Ti commit>`                   | 트랜잭션 Ti 정상 종료(커밋)          |
| **Abort**        | `<Ti abort>`                    | 트랜잭션 Ti 비정상 종료(중단)        |

* 데이터 변경 전에 반드시 로그부터 먼저 디스크에 기록해야 한다.

### 19.3.2 데이터베이스 변경

트랜잭션이 데이터를 수정할 때의 처리 과정은 다음과 같다.

1. **로그 레코드**를 먼저 생성하여 안정적 저장장치에 기록
2. 데이터베이스의 실제 데이터를 수정 (메모리 내의 버퍼 블록에)
3. (즉시 또는 지연되어) 버퍼 블록을 디스크에 기록

수정 방식에는 두 가지가 있다.

* **지연 갱신**: 트랜잭션이 완료(커밋)될 때까지 실제 DB에 변경을 반영하지 않음
* **즉시 갱신**: 트랜잭션이 진행 중일 때도 DB 변경이 즉시 일어날 수 있음 (일반적으로 사용)


### 19.3.3 동시성 제어와 복구

* 하나의 트랜잭션이 데이터 항목을 변경하면, 커밋 전까지 다른 트랜잭션이 같은 항목을 변경하면 안 된다.

  * 이를 위해 **2 단계 잠금 기법**을 사용하여, 트랜잭션이 커밋될 때까지 변경된 데이터에 대한 락을 유지한다.


### 19.3.4 트랜잭션 커밋

트랜잭션이 **commit** 될 때의 의미:

* 모든 연산이 정상적으로 끝났고,
* 이 변경사항들이 반드시 지속적으로 유지될 수 있도록 **commit 로그 레코드가 안정적 저장장치**에 기록된 상태

### 19.3.5 로그를 이용한 트랜잭션 redo와 undo

장애 발생 후 복구 시 로그를 통해 두 가지 주요 작업을 수행:

| 작업              | 설명                                                |
| ----------------- | --------------------------------------------------- |
| **Redo (재실행)** | 커밋 완료된 트랜잭션의 변경사항을 DB에 재적용       |
| **Undo (취소)**   | 커밋되지 않은 트랜잭션의 변경사항을 취소 (원상복구) |

* 커밋된 트랜잭션은 반드시 **Redo** 되어야 하고,
* 중단되었거나 커밋되지 않은 트랜잭션은 반드시 **Undo** 해야 한다.


### 19.3.6 검사점

장애 복구 시 로그를 처음부터 끝까지 검색하는 것은 비효율적이므로,
DBMS는 주기적으로 **체크포인트(checkpoint)** 를 생성하여 효율적인 복구를 지원한다.

**체크포인트 과정**

1. 로그를 메모리에서 디스크로 기록
2. 수정된 모든 버퍼 블록을 디스크에 기록
3. 체크포인트 로그 레코드(`<checkpoint L>`)를 디스크에 기록
   (L은 체크포인트 시점에 활성화된 트랜잭션 리스트)

**체크포인트 활용**

* 장애 발생 시, 마지막 체크포인트 이후의 로그만 처리하여 효율적인 복구 수행 가능

## 19.4 복구 알고리즘

장애 후 시스템 재시작 시, 복구 알고리즘은 다음 두 단계로 진행된다.

1. **Redo(재실행) 단계**
2. **Undo(취소) 단계**

이를 통해 데이터베이스의 일관성을 유지한다.

### 19.4.1 트랜잭션 롤백

정상 실행 도중 **트랜잭션이 실패하여 롤백되는 경우**를 처리하는 방법이다.

**트랜잭션 롤백 수행 과정**

* 로그를 뒤에서부터 앞으로 스캔하며 해당 트랜잭션이 수행한 변경을 역순으로 되돌림 (Undo 수행)
* Undo가 수행될 때도 **보상 로그 레코드(compensation log record, redo-only)** 를 남겨 재실행 가능성을 남김
* 트랜잭션의 시작 로그 레코드(`<Ti start>`)까지 스캔이 끝나면 트랜잭션의 abort 로그 레코드를 추가(`<Ti abort>`)


### 19.4.2 시스템 장애 후의 복구

시스템 충돌 후 재시작할 때의 복구 알고리즘은 두 단계로 구성된다.

#### **Redo 단계 (재실행)**

* 로그를 **가장 최근의 체크포인트**부터 앞으로 읽어나가면서, 모든 작업을 다시 재수행한다.
* **Redo** 과정에서 완료된 작업뿐 아니라 실패한 작업도 모두 재실행 → 이를 **재현(repeating history)** 이라고 함
* Redo 과정 중:

  * 새로운 트랜잭션 발견 → Undo 리스트에 추가
  * 트랜잭션의 commit 또는 abort 로그 발견 → Undo 리스트에서 제거

Redo 단계가 끝나면 **Undo 리스트에는 미완료된 트랜잭션만 남는다.**

#### **Undo 단계 (취소)**

* Undo 리스트의 트랜잭션을 대상으로 로그를 역방향으로 탐색하여 복구 수행
* 각 트랜잭션에 대해 롤백과 마찬가지로 Undo 작업 수행하고 보상 로그 기록
* 각 트랜잭션의 시작(`<Ti start>`) 로그를 발견하면 abort 레코드를 추가하고 Undo 리스트에서 삭제
* 모든 트랜잭션이 Undo되면 복구 알고리즘 종료


### 19.4.3 커밋 처리 최적화

* 각 트랜잭션이 commit 될 때마다 디스크로 로그를 강제로 쓰는 것은 성능 저하를 일으킬 수 있음.
* 이를 해결하기 위해 **그룹 커밋** 이라는 기법을 사용한다.

**그룹 커밋 기법**

* 일정 기간 또는 일정 개수의 트랜잭션이 commit을 기다리도록 하여, 로그 레코드를 한 번에 디스크에 기록
* 이를 통해 commit 속도가 빨라지고, 시스템 성능이 향상됨


## 19.5 버퍼 관리

### 19.5.1 로그 레코드 버퍼링

로그 레코드를 매번 바로 디스크에 쓰면 성능이 매우 저하된다. 이를 방지하기 위해:

* 로그 레코드를 메모리의 **로그 버퍼(log buffer)** 에 임시 저장한 후, 여러 로그 레코드를 한 번에 디스크로 기록한다.
* 그러나 다음 규칙들을 반드시 지켜야 한다.

  * 트랜잭션의 **commit 로그**는 반드시 즉시 디스크에 기록(안정적 저장장치).
  * 데이터 변경 사항이 담긴 로그 레코드는, 변경된 데이터 페이지를 디스크로 출력하기 **전에** 반드시 디스크에 기록.

### 19.5.2 데이터베이스 버퍼링

버퍼 내 데이터를 언제 디스크에 쓰는지 정책에 따라 두 가지로 나눈다.

| 정책              | 설명                                                               | 장단점                        |
| ----------------- | ------------------------------------------------------------------ | ----------------------------- |
| **Force 정책**    | 트랜잭션이 commit될 때마다 수정된 모든 데이터를 즉시 디스크에 기록 | 안정성 높지만 성능 저하       |
| **No-force 정책** | commit되어도 버퍼 블록을 즉시 디스크에 쓰지 않고 나중에 기록 가능  | 성능 좋지만 장애 시 복구 부담 |

* 대부분 시스템은 **no-force 정책** 사용 (성능 향상)
* **Steal 정책**: 커밋되지 않은 데이터를 버퍼에서 디스크로 미리 기록할 수 있음 (일반적으로 사용)
  
### 19.5.3 버퍼 관리에서 운영체제의 역할

버퍼 관리는 두 가지 방법으로 이루어질 수 있다.

* **DBMS가 직접 버퍼 관리**

  * DBMS가 메모리의 일부를 고정적으로 확보하여 관리
  * 성능 최적화 가능하지만 메모리 활용에 비효율적일 수 있음

* **OS의 가상메모리(virtual memory)를 활용한 관리**

  * DBMS가 OS 가상 메모리를 이용하여 더 유연하게 메모리 관리 가능
  * 단, OS가 디스크 쓰기 작업을 강제로 수행할 수 있어서 성능이 저하될 수 있음 (중복된 디스크 쓰기 발생 가능)


### 19.5.4 퍼지 검사점 기법

일반 체크포인트 시에는 데이터베이스 쓰기 작업이 잠시 멈춰져 성능 저하가 발생한다.
이를 개선하기 위해 사용하는 방법이 **Fuzzy Checkpointing**이다.

* 퍼지 체크포인트는 체크포인트 기록 이후 수정된 페이지들을 즉시 디스크에 쓰지 않고, 점진적으로 수행 가능하다.

* 체크포인트 도중에도 트랜잭션의 데이터 변경이 허용되기 때문에, 처리 지연을 최소화하여 성능 향상.

* 장애 시 체크포인트가 완료되지 않은 경우, 최근 완료된 체크포인트만을 사용해 복구 수행.


## 19.6 비휘발성 저장 장치에 손실이 발생하는 장애

비휘발성 저장장치(**디스크**) 자체가 물리적으로 손상되는 드문 경우에 대한 복구 전략이다.

* 이런 장애는 드물지만, 한 번 발생하면 데이터가 심각하게 손상될 수 있어 반드시 대비가 필요하다.


### 복구 전략 (Recovery Strategy)

이런 경우 복구 전략은 다음과 같이 구성된다.

* 주기적으로 데이터베이스 전체 내용을 **안정적 저장장치(예: 테이프, 원격 스토리지)** 에 **덤프(dump)**한다. (예: 하루 1회)
* 장애가 발생하면 가장 최근의 덤프를 사용하여 데이터베이스를 복원한 후, 그 시점 이후의 **로그를 활용하여 재실행(Redo)**하여 최근 일관된 상태로 복구한다.


### 데이터베이스 덤프 과정

* **덤프 과정** 동안에는 트랜잭션이 수행되지 않도록 잠시 중단함.

| 덤프 절차 | 설명                                                    |
| --------- | ------------------------------------------------------- |
| ①         | 모든 로그 레코드를 디스크에 기록                        |
| ②         | 모든 버퍼 블록을 디스크에 기록                          |
| ③         | 전체 데이터베이스 내용을 안정적 저장장치에 복사         |
| ④         | 덤프가 완료되었음을 나타내는 로그 레코드(`<dump>`) 기록 |

* 장애 발생 시 복구는 마지막 덤프 이후의 로그만 재실행하면 되므로, 복구가 간단하고 효율적이다.


### SQL 덤프 (SQL Dump)

* 데이터베이스 덤프 외에도 DB를 재구성할 수 있는 **SQL 덤프** 형태도 있음.
* 이는 DDL과 insert문으로 구성된 SQL 명령어를 파일로 출력하여, 나중에 다른 DB 환경에서도 손쉽게 복원할 수 있다.


### 퍼지 덤프 (Fuzzy Dump)

* 덤프 중에도 트랜잭션 수행을 중단하지 않고 점진적으로 덤프를 수행하는 기법 (**퍼지 덤프**)도 사용 가능
* 이를 통해 시스템 성능 저하를 최소화할 수 있다.

## 19.7 원격 백업 시스템을 통한 고가용성

* 전통적인 데이터베이스 시스템은 재난(화재, 홍수, 지진 등) 발생 시 데이터를 잃을 위험이 있다.
* **고가용성(high availability)** 을 달성하기 위해, 주(primary) 사이트 외에 원격(backup) 사이트를 두고 데이터를 실시간 동기화한다.
* 이를 통해 주 사이트에 장애가 발생해도 중단 없이 데이터베이스 운영을 유지할 수 있다.

### 원격 백업 시스템의 구조

* **Primary site (주 사이트)**: 트랜잭션 처리 수행 및 로그 기록
* **Remote backup site (원격 백업 사이트)**: 주 사이트에서 발생하는 모든 로그를 전달받아 지속적으로 동기화

장애 발생 시:

* 원격 백업 사이트가 복구 절차를 수행하여 최신 상태로 복원
* 복구 후 원격 백업 사이트가 새로운 Primary로 운영을 계속함


### 원격 백업 시스템의 핵심 이슈

**① 장애 탐지 (Detection of failure)**

* 주 사이트의 장애 여부를 정확히 감지하는 것이 중요하다.
* 여러 개의 독립된 네트워크 연결 및 수동 확인 절차를 통해 신뢰성 있는 장애 판단을 수행한다.

**② 제어권 이관 (Transfer of control)**

* 주 사이트 장애 시 백업 사이트로의 제어권 전환이 이루어진다.
* 주 사이트가 복구된 후 다시 주 사이트로 제어권을 넘겨받을 수도 있다.
* IP 전환 또는 프록시(proxy) 서버를 통해 제어 전환을 원활히 수행한다.

**③ 복구 시간 (Time to recover)**

* 로그가 커질수록 복구 시간이 길어진다.
* 백업 사이트는 주기적으로 로그를 적용하여 복구 시 지연을 최소화한다.
* **최신 준비 구성(Hot spare 구성)**: 로그를 실시간으로 적용하여 장애 즉시 즉각적인 복구가 가능하도록 준비된 상태

### 지속성 수준에 따른 분류

| 지속성 수준       | 설명                                                                            | 장단점                                                  |
| ----------------- | ------------------------------------------------------------------------------- | ------------------------------------------------------- |
| **One-safe**      | 주 사이트만 안정적 기록 후 commit                                               | 빠른 commit 가능하지만, 장애 시 데이터 유실 가능성 존재 |
| **Two-very-safe** | 주 사이트 및 백업 사이트 모두 기록 후 commit                                    | 데이터 유실 방지, 그러나 한 사이트 장애 시 서비스 중단  |
| **Two-safe**      | 두 사이트가 모두 운영될 때는 two-very-safe, 백업 사이트 장애 시 one-safe로 동작 | 장애 상황에서도 데이터 손실 최소화 및 고가용성 보장     |

* 일반적으로 **Two-safe** 방식이 많이 사용됨 (장애 내성 높고 균형 잡힌 방식)

### 읽기 전용 쿼리 지원

* 원격 백업 사이트에서 읽기 전용 트랜잭션을 수행하도록 허용하여 주 사이트 부하 감소 가능
* 읽기 전용 트랜잭션은 **스냅샷 고립**을 통해 데이터 일관성 보장

### 기타 고가용성 기술

* 파일 시스템 또는 SAN(Storage Area Network) 레벨에서도 원격 복제를 지원
* 분산 데이터베이스를 이용한 데이터 복제 및 가용성 증가 가능 (다만, 관리 비용 및 복잡성 증가)

## 19.8 조기 잠금 해제와 논리적 Undo 연산

* 일반적인 복구 기법은 락(lock)을 트랜잭션 종료(commit 또는 abort)까지 유지한다.
* 하지만 특정 상황(특히 인덱스 관리 등)에선 락을 조기에 해제하는 게 효율적이다.
* 조기 락 해제를 사용하면, 장애 발생 시 일반적인 물리적 Undo(이전 값을 복원) 대신 **논리적 Undo** 를 수행해야 한다.

### 19.8.1 논리적 연산

* B+ 트리 인덱스 등 자주 변경되는 데이터 구조에서 많이 사용됨
* **논리적 연산**은 특정 연산(insert, delete 등)의 취소를 동일한 연산의 반대 연산으로 처리함

  * 예: insert → delete로 undo, delete → insert로 undo
* 조기에 락을 해제한 경우, 기존 값을 복구하면 이미 다른 트랜잭션에 의해 변경된 값이 손상될 수 있으므로 논리적 undo가 필요함

### 19.8.2 논리적 Undo 로그 레코드

* **논리적 Undo**를 위한 로그는 두 가지 유형으로 구성된다.

  * 연산 시작: `<Ti, Oj, operation-begin>`
  * 연산 완료: `<Ti, Oj, operation-end, Undo 연산>`

    * Undo 연산에는 연산을 되돌리기 위한 논리적 연산 정보가 담겨 있음

* 논리적 로그는 Undo에만 사용되며, Redo는 기존 물리적 로그로 수행한다.

### 19.8.3 논리적 Undo를 이용한 트랜잭션 롤백

논리적 연산을 사용한 트랜잭션 롤백 과정:

* 로그를 역방향으로 읽어나가면서 처리:

  1. **operation-end** 로그 발견 시:
     Undo 연산(논리적 연산)을 수행하고, `<Ti, Oj, operation-abort>` 로그 기록
     operation-begin 로그가 나올 때까지 이 트랜잭션의 물리적 로그는 건너뛰기(skip)

  2. **operation-abort** 로그 발견 시:
     이미 undo된 연산이므로 이와 관련된 로그를 건너뜀 (중복 Undo 방지)

  3. **operation-begin** 로그 발견 후:
     일반 물리적 undo 수행


### 19.8.4 논리적 Undo 연산에서 동시성

* 논리적 undo 수행 시 **병행성 문제**가 발생할 수 있음
* 조기에 락을 해제했기 때문에, 논리적 undo가 실행되는 동안 다른 트랜잭션이 데이터를 변경했을 가능성이 존재
* 따라서 논리적 연산 시, 논리적 undo가 가능한 수준의 낮은 레벨 락(short-term lock)을 확보하여 병행성 문제를 해결해야 함
* 이를 충족하지 않으면 Undo 과정에서 데이터 일관성이 깨질 수 있다.

## 19.9 ARIES

ARIES는 복구 알고리즘 중 가장 발전된 형태로, 높은 성능과 효율적인 복구를 제공한다.

ARIES는 다음의 주요 특징을 갖는다.

* **로그 순서 번호(Log Sequence Number, LSN)**를 이용한 효율적인 관리
* **물리적-논리적 redo** 지원
* **Dirty Page Table(변경된 페이지 테이블)** 사용하여 불필요한 Redo 최소화
* 효율적인 **퍼지 체크포인트** 수행 지원

### 19.9.1 자료구조

ARIES가 사용하는 주요 데이터 구조는 다음과 같다.

| 자료구조                           | 설명                                                                            |
| ---------------------------------- | ------------------------------------------------------------------------------- |
| **Log Sequence Number (LSN)**      | 로그 레코드마다 부여된 고유 번호 (로그 레코드의 위치 식별)                      |
| **PageLSN**                        | 각 데이터 페이지에 기록되는 LSN. 페이지에 적용된 최신 로그 레코드 번호를 나타냄 |
| **PrevLSN**                        | 같은 트랜잭션의 바로 이전 로그 레코드를 가리킴                                  |
| **Compensation Log Records (CLR)** | Undo 작업 시 Redo를 위해 생성되는 보상 로그 (redo-only log)                     |
| **DirtyPageTable**                 | 메모리에서 변경된 페이지의 정보를 기록하고 관리                                 |

* 이 구조들을 이용하여 복구 시 읽어야 하는 로그의 양을 최소화하고, 효율적이고 신속한 복구를 지원한다.

### 19.9.2 복구 알고리즘

ARIES의 복구 알고리즘은 3가지 단계로 구성된다.

| 단계                             | 목적                                                                                | 설명                                                                                                            |
| -------------------------------- | ----------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| **Analysis Pass**<br>(분석 단계) | 복구할 트랜잭션과 페이지를 식별하고, Redo의 시작 지점(로그상에서의 최소 LSN)을 결정 | 최근 체크포인트부터 로그를 전방향으로 읽으며 DirtyPageTable과 Undo할 트랜잭션 목록을 구성                       |
| **Redo Pass**<br>(재실행 단계)   | 장애 직전의 데이터베이스 상태로 복구 (역사 반복)                                    | Analysis에서 결정된 Redo 지점부터 로그를 전방향으로 읽으면서 각 페이지의 PageLSN을 비교하여 Redo 필요 여부 판단 |
| **Undo Pass**<br>(취소 단계)     | 미완료된 트랜잭션 취소                                                              | Undo 리스트의 트랜잭션을 대상으로 로그를 후방향으로 읽으면서 Undo 수행. Compensation log (CLR) 생성             |

* 복구 과정에서 Undo 작업은 CLR을 이용하여 반드시 Redo가 가능하도록 처리된다.


### 19.9.3 다른 특성

ARIES는 다음과 같은 추가적인 기능과 최적화 기법을 제공한다.

* **중첩된 최상위 작업**: 특정 연산(페이지 할당 등)은 트랜잭션이 취소되어도 복구되지 않도록 처리 가능
* **복구 독립성**: 특정 페이지를 독립적으로 복구하여 다른 페이지의 복구와 상관없이 사용할 수 있음
* **저장점**: 트랜잭션 도중 저장점을 설정하여 그 지점까지만 트랜잭션을 부분적으로 Undo할 수 있음 (부분적인 Undo 지원)
* **세밀한 단위의 장금**: 세밀한 수준(레코드 수준)의 락을 허용하여 병행성을 높임
* **복구 최적화**: DirtyPageTable을 활용한 효율적 페이지 프리페칭(prefetching)과 Out-of-order Redo 지원 등 복구 성능 최적화 가능

## 19.10 메인 메모리 데이터베이스의 복구

**메인 메모리 데이터베이스 시스템**은 전체 데이터를 메인 메모리에 저장하여 **매우 빠른 성능**을 제공하지만,
메모리는 휘발성이기 때문에 **시스템 장애 발생 시 모든 데이터가 사라질 수 있음** → 철저한 복구 메커니즘 필요

### 최적화 전략
* **인덱스의 빠른 재생성**

  * 메인 메모리 DB는 인덱스를 매우 빠르게 재구성할 수 있기 때문에,
    인덱스 업데이트에 대해 redo 로그를 남기지 않는 경우가 많음
  * 단, 트랜잭션 abort 처리를 위한 undo 로그는 메모리 상에 저장 (디스크 기록 불필요)

* **Redo-only 로깅 및 멀티버전**

  * 로그 기록량을 줄이기 위해 **redo logging**만 수행하는 시스템도 많음
  * 체크포인트는 주기적으로 수행되며, 체크포인트 이후에는 로그의 replay(redo)만으로 복구
  * uncommitted 트랜잭션의 변경분은 복구 시 무시/삭제 (가비지 컬렉션 필요)

* **빠른 병렬 복구**

  * 전체 DB를 메모리에 올리고 복구가 끝나야 트랜잭션 처리가 가능하므로
    **복구 속도가 매우 중요**
  * 데이터와 로그를 파티션(분할)하고, 각 파티션별로 멀티코어를 이용해 병렬 복구를 진행함