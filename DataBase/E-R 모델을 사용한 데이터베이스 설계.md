# E-R 모델을 사용한 데이터베이스 설계

개체-관계(E-R) 데이터 모델에만 집중하는 장이다.

E-R 모델은 데이터베이스에서 표현할 개체를 식별하고, 이 개체들의 연관성을 표현하는 방법을 제공한다.

데이터베이스 설계는 관계형 데이터베이스 설계와 연관된 제약 조건의 집합으로 표현된다.

## 6.1 설계 과정의 개요

데이터베이스 응용 프로그램(예: 채팅앱, 쇼핑몰, 수강신청 시스템 등)을 만드는 일은 복잡한 작업으로 다음과 같은 여러 설계 작업이 필요하다.

- 데이터베이스 스키마 설계
- 데이터 접근 및 갱신을 위한 프로그램 설계
- 보안 및 접근 제어 설계

이 장에서는 데이터베이스 스키마 설계, 즉 어떤 데이터를 어떻게 구조화해서 저장할지를 정하는 것에 초점을 맞춘다.

### 6.1.1 설계 단계

1. 요구사항 분석
    - 사용자와 도메인 전문가들과 협력하여 필요한 데이터와 기능을 명확히 파악함.
    - 결과물은 사용자 요구 사항 명세서
2. 개념적 설계
    - 데이터 모델 선택 → 일반적으로 E-R 모델 사용
    - 엔터프라이즈의 개요를 나타내는 개념적 스키마 작성
        - 어떤 개체(예: 학생), 어떤 속성(예: 이름), 어떤 관계(예: 수강), 어떤 제약조건이 있는지 표현
    - 결과는 E-R 다이어그램으로 시각화됨
3. 기능적 요구사항 반영
    - 데이터에 대해 어떤 연산이 수행될 것인지 명시 (삽입, 조회, 수정, 삭제 등)
    - 스키마가 기능 요구를 만족하는지 점검
4. 논리적 설계
    - 개념적 스키마 → 논리적 스키마로 변환
    - DBMS가 사용하는 데이터 모델 (관계형 모델 등)로 매핑
5. 물리적 설계
    - 저장 구조, 인덱스, 클러스터링 방식 등을 결정
    - 성능과 저장 효율 고려

### 6.1.2 설계 대안

다양한 실세계 객체(예: 사람, 장소, 상품 등)를 어떻게 데이터베이스로 모델링할지를 고려해야 한다.

이러한 객체는 개체(Entity)로 표현된다.

예시: 대학 데이터베이스

- 개체: 학생(student), 강사(instructor), 학과(department), 과목(course), 개설 강좌(section)
- 관계: 수강(takes), 강의(teaches), 지도교수(advisor)

### 스키마 설계 시 피해야 할 문제

1. 중복(Redundancy)
    - 동일 정보를 여러 테이블에 중복 저장 → 일관성 붕괴 가능성
    - 예: 과목 이름을 여러 테이블에 저장 후, 한 곳만 수정되면 정보 불일치 발생
2. 불완전성(Incompleteness)
    - 특정 데이터를 저장할 수 없는 구조
    - 예: 아직 주문되지 않은 메뉴는 주문 테이블에 존재할 수 없음

## 6.2 개체-관계 모델

E-R 모델은 고수준 개념적 데이터 모델로, 현실 세계를 개체와 관계로 표현한다. E-R 다이어그램은 이를 시각화한다.

### 6.2.1 개체 집합

- 개체(Entity): 현실 세계의 구분 가능한 객체 (예: 학생, 교수)
- 속성(Attribute): 개체의 특성 (예: 이름, ID)
- 개체 집합(Entity Set): 동일한 유형의 개체들의 모음

각 개체는 고유 식별자를 가진다 (예: 학번, 사번 등).
E-R 다이어그램에서는 개체는 직사각형, 속성은 타원형, 기본키는 밑줄로 표현된다.

### 6.2.2 관계 집합

- 관계(Relationship): 두 개 이상의 개체 간의 연관성
- 관계 집합(Relationship Set): 동일 유형의 관계들의 집합

관계는 다이아몬드로 표시되며, 개체와 선으로 연결된다.
관계는 속성을 가질 수 있으며, 이항(Binary), 삼항(Ternary) 또는 n-항 관계로 분류된다.

## 6.3 복합 속성

각 속성이 가질 수 있는 값의 집합이 존재하는데 이를 그 속서의 **도메인** 혹은 **값 집합**이라 한다.

### 속성 유형

E-R 모델에서 사용될 때 속성은 다음과 같은 유형으로 분류한다.

### 1. 단순 속성 (Simple Attributes)

- 더 이상 나눠지지 않는 기본적인 속성.
- 예시: ID, 학점, 성별 등.

### 2. 복합 속성 (Composite Attributes)

- 여러 하위 속성으로 나누어지는 속성.
- 예시:
    - 이름(name): 이름(first name), 중간 이름(middle initial), 성(last name).
    - 주소(address): 거리(street), 도시(city), 주(state), 우편번호(postal code).
    - 거리(street) 속성 또한 거리 번호, 거리명, 아파트 번호 등으로 나눌 수 있음.

> 복합 속성의 장점:
> 
> - 관련된 속성들을 묶어 설계를 명확하게 만듦.
> - 하위 속성 단위로 접근 가능.

### 3. 단일값 속성 (Single-valued Attributes)

- 하나의 개체에 대해 하나의 값만 가짐.
- 예시: 학생 ID, 생년월일 등.

### 4. 다중값 속성 (Multivalued Attributes)

- 하나의 개체가 여러 개의 값을 가질 수 있음.
- 예시:
    - 교수의 전화번호(교수마다 여러 개 가능).
    - 교수의 부양가족 이름(부양가족이 여러 명 가능).

### 5. 유도 속성 (Derived Attributes)

- 다른 속성의 값으로부터 계산하여 얻어짐.
- 실제로 저장되지 않고, 필요할 때 계산.
- 예시:
    - 교수의 나이(age): 현재 날짜와 생년월일로 계산 가능.
    - 학생 지도 수: 관련된 학생 개체 수를 계산.

### 6. 기본(저장) 속성 (Base/Stored Attributes)

- 실제로 데이터베이스에 저장되는 속성.
- 유도된 속성과 대조됨.
- 예시: 생년월일, 전화번호 등.

### E-R 다이어그램 표기법 예시

- 복합 속성은 하위 속성으로 연결하여 표시.
- 다중값 속성은 중괄호 `{ }`로 표시 (예: `{전화번호}`).
- 유도된 속성은 괄호 `( )`로 표시 (예: `(나이)`).

> 복합 속성을 명확하게 구분하면 데이터베이스 설계를 효율적이고 유지보수하기 쉽게 만들 수 있다.

## 6.4 대응 카디널리티

### 매핑 카디널리티란?

- 관계 집합에서 하나의 개체가 연결될 수 있는 **다른 개체의 수**를 나타냄.
- 이항(binary) 관계에 자주 사용되며, 실제 세계의 관계 제약을 모델링할 때 유용함.

### 주요 유형

- **일대일 (1:1)**: 양쪽 개체가 최대 1개의 상대 개체와만 연결됨.
- **일대다 (1:N)**: 한쪽 개체는 여러 개와 연결, 다른 쪽은 최대 1개.
- **다대일 (N:1)**: 반대 방향의 일대다.
- **다대다 (N:M)**: 양쪽 모두 여러 개와 연결 가능.

### 참여 제약

- **전체 참여 (Total Participation)**: 모든 개체가 최소 하나의 관계에 참여 → **이중선**으로 표시.
- **부분 참여 (Partial Participation)**: 일부 개체만 관계에 참여 → **단일선**으로 표시.

### E-R 다이어그램 표기법

- **화살표(→)**: "1" 방향을 나타냄.
- **선(line)**: 관계의 참여 형태를 나타냄.
    - `1..1`: 정확히 하나 (필수 참여)
    - `0..*`: 제한 없음 (선택 참여)
    - `1..*`: 최소 1개 이상

### 예시 (advisor 관계)

- 학생은 정확히 한 명의 지도교수를 가져야 함 → `1..1`
- 교수는 0명 이상의 학생을 지도할 수 있음 → `0..*`
- 이 경우:
    - 관계는 **교수 → 학생 방향의 일대다 (1:N)**
    - **학생은 전체 참여**, **교수는 부분 참여**

> 주의: 0..*을 잘못 해석하여 방향을 반대로 이해하지 않도록 주의할 것.

### 대체 표현 가능성

- 위 제약 조건은 `이중선 + 화살표`로도 동일하게 표현 가능.

### 비이항 관계 집합 (3개 이상 개체 포함 관계)

- **예시**: 프로젝트 지도 관계 (proj_guide)
    - 학생이 최대 한 명의 교수만 지도자로 가질 수 있음
    - 이 경우, **instructor 방향으로만 화살표를 사용**
- **비이항 관계에서는 화살표는 최대 1개만 허용**
    - 이유: 2개 이상일 경우 해석이 모호해짐


## 6.5 주 키 (Primary Key)

### 6.5.1 개체 집합

- 각 개체는 유일해야 하며, 속성 값을 통해 식별됨.
- **기본 키(primary key)**: 개체를 유일하게 식별하는 속성(들)의 집합.
- 릴레이션 키 개념(슈퍼키, 후보키 등)이 동일하게 적용됨.

### 6.5.2 관계 집합

- 관계 집합은 참여 개체들의 기본 키(또는 + 자체 속성)를 통해 고유하게 식별됨.
- 관계 집합이 개체 속성만 포함할 경우:
    - 키 = 참여하는 개체들의 기본 키의 합집합
- 관계가 속성도 가질 경우:
    - 키 = 참여 개체 기본 키 합집합 + 관계의 속성들
- **다대다 관계**: 모든 참여 개체 키의 합이 기본 키
- **일대다 또는 다대일**: "다" 쪽 개체의 키가 관계의 기본 키

### 6.5.3 약한 개체 집합

- 자체 기본 키가 없음 → **식별 개체(identifying entity set)** 의 도움 필요
- 식별 키 = 식별 개체의 기본 키 + **구별자(discriminator)** 속성
- 관계는 항상 **다대일 (many-to-one)** 방향이며, 약한 개체는 **전체 참여(total participation)** 해야 함
- 약한 개체는 다른 관계에도 참여 가능 (예: time_slot)
- 약한 개체가 다른 약한 개체의 소유자가 될 수도 있음
- 하나의 약한 개체가 **여러 개의 식별 개체 집합**에 의존할 수도 있음
    - 이 경우: 약한 개체의 키 = 모든 식별 개체 키의 합집합 + 구별자

약한 개체는 "존재적으로 종속"된 개체를 표현하며, 이를 통해 설계의 명확성과 무결성을 확보할 수 있음.

## 6.6 개체 집합에서 중복 속성 제거하기

- E-R 설계 시, 먼저 **개체 집합**(student, instructor 등)을 정하고, 그에 필요한 **속성**을 선택.
- 이후 개체들 간 **관계 집합**(relationship sets)을 생성하면서, 일부 속성이 중복(중복 저장)될 수 있음.
- **중복 속성**은 설계 상 불필요한 복잡성과 데이터 불일치 가능성을 높이므로 제거 해야함.

### 중요성

- **좋은 E-R 설계**: 중복 속성을 최소화하여 저장 공간 낭비와 데이터 불일치 위험 줄임.
- 관계로 표현할 수 있는 정보는 속성으로 중복 저장하지 않도록 주의.
- “한 개체가 여러 개체와 연결 가능하다” 같은 제약을 명시적으로 관계로 표현해, 불필요한 가정을 피함.

이 과정을 통해 **데이터 구조가 단순**해지고, **데이터 무결성을 유지**하기 쉬우며, **추가 변경**(예: 여러 학과를 갖는 교수 등)이 일어날 때도 유연하게 대응 가능해진다.

## 6.7 E-R 다이어그램을 관계형 스키마로 변환하기

E-R 모델과 관계형 모델은 모두 현실 세계를 논리적으로 표현하는 추상 모델이다.

두 모델은 유사한 설계 원칙을 따르기 때문에, **E-R 스키마를 관계형 스키마로 변환하는 작업**이 가능하다.

각 개체 집합과 관계 집합은 고유한 릴레이션 스키마로 변환되며, 릴레이션 스키마의 이름은 대응되는 개체 집합이나 관계 집합의 이름을 따른다.

### 6.7.1 강한 개체 집합의 표현

1. **단순 속성** → 스키마 속성으로 직접 변환
2. **기본 키**는 개체 집합의 키와 동일
3. **복합 속성**은 하위 속성들로 분할, **다중값 속성**은 별도 릴레이션 생성
4. **유도 속성**(derived)은 저장 X

### 6.7.2 복합 속성을 가진 개체 집합의 표현

- 복합 속성 → 각각의 하위 속성으로 분해하여 스키마에 반영
- 다중값 속성은 별도의 스키마로 분리 (기본 키 + 해당 속성)

### 6.7.3 약한 개체 집합의 표현

- 강한 개체 집합의 기본 키 + 약한 개체 구별자 → 약한 개체 릴레이션의 기본 키
- 약한 개체와 식별 개체 간 **식별 관계**는 별도 릴레이션 없이 처리 (이미 약한 개체가 강한 개체 키를 포함)

### 6.7.4 관계 집합의 표현

- 관계가 참여하는 개체들의 기본 키 + 관계 자체의 속성 → 새 릴레이션 스키마
- 일대다(1:N), 다대일(N:1): "다" 쪽 개체의 키가 관계의 기본 키
- 다대다(M:N): 참여 개체들의 키를 모두 포함
- 설명 속성이 있다면 함께 포함

### 6.7.5 스키마의 중복성

- 관계가 단순히 약한 개체와 강한 개체를 연결하고, 이 정보가 이미 약한 개체 릴레이션에 포함되어 있다면, **별도의 관계 릴레이션은 필요 없다.**

### 6.7.6 스키마의 결합

- 일대다 관계이며 한쪽이 전체 참여인 경우, 관계 릴레이션을 해당 개체 릴레이션에 합칠 수 있음.
- 1:1 관계도 마찬가지로 하나로 합치는 것이 가능.

## 6.8 E-R의 확장된 특성

기본적인 E-R 모델만으로는 현실 세계의 복잡한 구조를 모두 표현하기 어렵다.

이를 보완하기 위해 E-R 모델은 **일반화, 특수화, 집계**와 같은 **확장된 특징**을 제공한다.

### 6.8.1 구체화

- **개체 집합** 내에서 특성에 따라 하위 그룹(서브 그룹)을 구분하는 과정
    - 예: `person` → `employee`, `student`
- 상위 개체 집합의 속성을 상속받고, **추가 속성**을 가질 수 있음
- Overlapping vs. Disjoint:
    - Overlapping: 한 개체가 여러 하위 집합에 속할 수 있음
    - Disjoint: 한 개체는 단 하나의 하위 집합에만 속함

### 6.8.2 일반화

- 여러 **유사한 개체 집합**을 **상위 집합**으로 통합하는 과정 (반대: 구체화는 상위에서 하위로 분기)
- `instructor`, `secretary` 등을 통합해 `employee`를 만들 수 있음

### 6.8.3 속성 상속

- 상위 개체 집합의 속성과 관계를 **하위 개체 집합**이 물려받음
- 예: `employee`는 `person`의 (ID, name, street, city)를 상속 + 추가적으로 salary 같은 속성

### 6.8.4 구체화/일반화에 대한 제약 조건

- **disjoint vs. overlapping**: 하위 집합이 서로 겹칠 수 있는지 여부
- **전체(total) vs. 부분(partial)**: 상위 개체가 반드시 하위 집합 중 하나에 속해야 하는지 여부
- 삽입/삭제 시에도 제약 사항 발생 (total이면 상위에 삽입 시 반드시 하위에도 삽

### 6.8.5 통합화

- **관계 자체**를 더 높은 수준의 "개체처럼" 취급하여, 다른 엔터티/관계와 연결하는 기법
- 예: `proj_guide`(instructor, student, project) 관계를 상위 엔터티로 보고, `evaluation`과 `eval_for`로 연결
- 관계 간의 관계를 명시적으로 모델링할 수 있도록 돕는 확장

### 6.8.6 릴레이션 스키마로의 변환

1. **일반화의 표현**:
    - (1) 상위 개체 스키마 + 각 하위 스키마
    - (2) disjoint & complete인 경우, 하위 스키마에 상위 속성을 포함해 상위 스키마 생략 가능
    - 외래 키 제약, 중복 문제 주의
2. 통합화의 표현:
    - 관계(aggregation)를 "엔터티처럼" 간주
    - 그 관계의 기본 키와 연결된 엔터티 스키마를 기존 규칙에 따라 변환
    - 별도 릴레이션 없이, 정의 관계가 그대로 "집약 엔터티" 역할 수행

확장 E-R 기능은 복잡한 모델링 상황(여러 단계의 전문화, 관계 간 관계)을 명확하게 표현할 수 있게 하며, 실제 데이터베이스 요구사항에 더 잘 부합하는 스키마를 설계하는 데 도움을 준다.


## 6.9 개체-관계 설계 쟁점

E-R 모델로 데이터베이스를 설계할 때는 설계자가 여러 가지 결정을 내려야 하며, 그 과정에서 설계 오류나 비효율적인 표현 방식이 발생할 수 있다.

### 6.9.1 E-R 다이어그램 작성 시 흔한 실수

1. **개체의 기본 키를 다른 개체 속성으로 직접 넣는 실수**
    - 예: student 개체에 dept_name(학과의 PK)을 속성으로 추가
    - → 대신 관계(stud_dept)로 표현해야 중복 방지
2. **관계 집합에 참여 개체의 키를 속성으로 중복 지정**
    - 관계는 이미 관련 개체를 암묵적으로 참조함
    - → E-R 단계에서 중복 삽입 불필요
3. **한 개체(또는 관계)에 단일 속성만 두어, 실제로는 여러 값을 못 담는 상황**
    - 예: takes 관계에 assignment, marks 단일 속성 → 여러 과제 표현 불가
    - → 과제를 약한 개체(assignment)로 모델링하거나 다중값 복합 속성 사용
4. **커다란 E-R 다이어그램을 적절히 분할하지 않음**
    - 개체 집합이 여러 페이지에 걸칠 때, 속성은 한 군데에만 명시

### 6.9.2 개체 집합 대 속성 사용의 비교

- 예: instructor 개체에 phone_number 추가
    - 추가 정보(위치 등)를 다루려면, phone을 별도 엔티티로 모델링(관계 inst_phone)
    - 단순히 번호만 관리하면 속성/다중값 속성으로 가능
- 결정은 "해당 속성이 독립적인 의미나 추가 속성·관계가 필요한지"에 따라

### 6.9.3 개체 집합 대 관계 집합 사용의 비교

- 예: student가 section을 수강(takes) → 이항 관계
- 대안: registration 엔티티(수강 레코드)를 만들고, (registration—student), (registration—section)으로 표현
    - 정보가 단순할 땐 관계로, 상세 정보가 많으면 별도 엔티티로
- "행위(action)나 사건(event)을 관계로 표현"한다는 접근도 유용

### 6.9.4 이진 대 비이진 관계 집합

- 대부분 관계는 이진(binary)이 많음
- 어떤 삼진(ternary) 관계는 여러 이항 관계로 분할 가능
    - 예: parent(아이, 어머니, 아버지) → mother, father 이항 관계로 대체
- n-ary 관계 → 새 엔티티 E + 여러 개의 이항 관계로 분해 가능 (모델 복잡도 증가, 제약 표현 문제)
- n-ary 관계가 실제로 필요한 경우도 있음
    - 예: proj_guide(교수, 학생, 프로젝트)는 단순히 (교수-프로젝트), (교수-학생)으로 나누면 세부 조합 표현 불가


## 6.10 데이터 모델링을 위한 대안적인 표기법

- E-R 다이어그램 같은 **시각적 모델링**은 데이터베이스 스키마 설계에서 중요.
- 도메인 전문가와 데이터 모델링 전문가 간 **의사소통**을 원활히 하려면 직관적 표기 필요.


### 6.10.1 대안적 E-R 표기법

1. **속성과 관계 표현**
    - Chen 표기 등: 엔티티(사각형), 속성(타원), 관계(마름모)
    - 기본 키: 속성명 밑줄
    - 관계 속성도 마름모에 타원 연결 가능
2. **카디널리티 제약 표기**
    - , `1` 라벨 사용 (왼쪽 그림)
    - crow’s-foot(까마귀발) 표기 (오른쪽 그림) → 이항 관계만 가능
    - 전참여( | ), 부분참여(○)를 관계선 반대편에 표시
3. **일반화(generalization) 표현**
    - 삼각형(triangle)으로 표기할 수 있음 (속이 빈 화살표 대안)
4. **Chen 표기법**
    - 타원에 속성, 마름모에 관계 표현
    - 원조(오리지널) E-R 논문(1976)에서 소개된 표기
5. **IDEF1X**
    - 1993년 NIST가 정한 표준
    - crow’s-foot, 전참여( | ), 부분참여(○) 등 다양한 표기 포함
6. **현대 E-R 모델링 툴과 UML 표기 근접**
    - 속성은 엔티티 박스 내부에 적고, 관계를 간결히 나타내는 방식 선호
    - UML 클래스 다이어그램 표기와 유사

> - 엔티티 뷰 vs. 릴레이션 뷰를 구분하는 툴도 있음.
> - E-R 모델에 없는 릴레이션 속성(예: instructor의 dept_name)은 실제 관계형 스키마에선 관계를 통해 추가될 수 있음.


### 6.10.2 통합 모델링 언어

- **객체 지향** 소프트웨어 설계를 위한 표준(OMG 주관).
- 모델링 범위: 사용자 인터랙션(Use Case), 작업 흐름(Activity), 구현 구조(Implementation) 등.
- 이 중 **클래스 다이어그램**이 데이터 표현 측면에서 **E-R 모델**과 가장 유사.
1. **클래스 다이어그램 vs. E-R 다이어그램**
    - UML에서 “객체”는 **속성 + 메서드**를 가짐. (E-R의 “엔티티”는 속성만)
    - 클래스 다이어그램은 **메서드까지** 함께 표시 가능.
    - 연관 관계(association)는 선으로 표현, 관계 이름/역할을 선 근처에 표기.
    - 속성 접근 제어: `+`(public), `-`(private), `#`(protected).
2. **복합·다중값·유도 속성**
    - UML은 기본 지원하지 않음.
    - 유도 속성(derived attributes)은 **매개변수 없는 메서드**로 대체 가능.
3. **카디널리티 표기(l..h)**
    - `l..h` 형태는 E-R과 유사하나, **제약 기호가 반대편**에 붙음에 주의.
    - 예: `0..1`이 E1 쪽, `0..*`이 E2 쪽 → 사실 E2→E1 다대일(many-to-one).
4. **일반화(ISA 관계)**
    - 표기 방식은 E-R과 거의 동일.
    - `disjoint`, `overlapping` 등의 구분도 E-R과 유사하게 표시.
5. **집약(aggregation)/합성(composition)**
    - UML에서 **composition**(채워진 마름모)은 약한 개체와 유사. (E2가 E1에 존재적으로 종속)
    - **aggregation**(비어 있는 마름모)은 E2가 E1에 포함되지만 **독립**적으로 존재 가능.
6. **추가 정보**
    - UML은 클래스 다이어그램 외에 **Use Case**, **Activity**, **Implementation** 등 다양한 다이어그램 제공.
    - 객체 지향 언어의 **인터페이스** 개념 등도 표현 가능.

## 6.11 데이터베이스 설계의 다른 관점

스키마 설계가 데이터베이스 설계의 유일한 구성요소라는 오해하지 말 것

### 6.11.1 기능 요구 사항

- 애플리케이션에서 지원해야 할 **트랜잭션**(갱신)과 **쿼리**(조회) 규칙이 존재
- 인터페이스 설계도 포함
- 일부 사용자에게만 특정 데이터 접근·트랜잭션 허용 → **권한 부여(authorization)** 중요

### 6.11.2 데이터 흐름, 워크플로

- DB 애플리케이션은 종종 기업 애플리케이션의 한 부분
- 여러 전용 소프트웨어와 상호작용, 예: 출장 경비 보고서 → 상사 승인 → 회계 처리
- 워크플로(데이터+태스크의 조합): 데이터베이스와 여러 단계에서 상호작용
- DB에 **워크플로 자체**(태스크, 라우팅 등)도 저장 가능
- 비즈니스 프로세스(흐름)까지 이해해야 제대로 모델링 가능

### 6.11.3 스키마의 진화

- DB 설계는 한 번에 완성 X, 조직 요구가 계속 변함
- 개념·논리·물리 스키마 단계에서 수정 필요할 수 있음
- 좋은 설계는 미래 확장을 염두 → 변경 시 영향 최소화
- 예: 한 강사가 한 학과만 가지는 제약 → 이후 공동 임용 허용 시 큰 수정 필요할 수도
- 근본적 제약 vs 바뀔 가능성 큰 제약 구분