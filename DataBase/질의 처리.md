
# Chapter9. 질의 처리

---

## 1. 질의 처리 단계

<br>

질의 -> 파싱과 변환 -> 관계 대수 표현 -> 최적화 -> 평가 계획 -> 실행 -> 결과

<br>

1) **파싱과 변환** : 주어진 질의를 시스템 내부 표현 형태(평가 기본 단위)로 변환
   - 평가 기본 단위 : 대수 표현식 내의 연산 처리 방법(주석)을 포함한 관계 대수 표현
2) **최적화** : 질의 처리 비용을 최소화 하는 질의 평가 계획 도출
3) **평가** : 질의 수행 엔진이 계획을 수행한 후 질의에 대한 결과 반환

<br>

## 2. 질의 비용의 측정

<br>

1) 응답 시간은 실제 수행하기 전에 추정하기 어려워서 부적합
   - 버퍼의 내용에 의존하는데, 질의 최적화 단계에서 버퍼 정보를 이용할 수 없으며 이용 가능해도 고려하기 어려움
   - 다수의 디스크 사용 시 디스크 접근 분포에 의존하는데, 디스크상의 데이터 분포에 대한 자세한 정보 추정이 어려움
2) 일반적으로 전체 자원 소비(전체 디스크 접근 시간)를 최소화 하려고 함

<br>

> 디스크에서 자료 한 블록 전송 시간을 t<sub>r</sub>, 평균적인 블록 접근 시간이  t<sub>s</sub>일 때  
> b개의 블록을 전송하고, S번 임의 I/O 접근을 수행해야 한다면 질의 평가 계획 비용은
> 
> **b * <sub>r</sub> + S * t<sub>s</sub>**

<br>

## 3. 선택 연산

<br>

- **클러스터링(기본) 인덱스** : 데이터가 물리적으로 저장된 순서대로 만들어진 인덱스
- **보조 인덱스** : 데이터의 물리적 순서와 무관하게 추가로 만들어진 인덱스
  * 일반적으로 보조 인덱스에는 레코드에 대한 직접적인 포인터가 아닌 검색 키가 저장되므로 레코드에 접근하는 비용이 클러스터링 인덱스에 비해 큼

<br>

1) **선형 검색**
   - 각 파일 블록을 스캔하고 모든 레코드에 대해 선택 조건이 만족하는지 검사
   - 파일의 순서, 인덱스 여부, 선택 연산 속성과 상관없이 사용 가능
   - 일반적으로 다른 알고리즘보다 속도가 느림
2) **클러스터링 인덱스 + 키(유일)에 대한 동등 비교**
   - 인덱스에 해당하는 하나의 레코드를 바로 검색
3) **클러스터링 인덱스 + 키가 아닌 것(중복)에 대한 동등 비교**
   - 파일이 검색 키로 정렬되어 있으므로 연속적으로 저장된 레코드들을 검색
4) **보조 인덱스 + 키에 대한 동등 비교**
   - 인덱스에 해당하는 하나의 레코드를 바로 검색
5) **보조 인덱스 + 키가 아닌 속성에 대한 동등 비교**
   - 검색되는 수만큼 레코드를 매번 검색
   - 최악의 경우 선형 검색보다 느림
     * 선형 검색은 한 블록내의 여러 레코드를 검색할 때 해당 블록을 한번만 가져옴
     * 보조 인덱스의 경우 한 블록내의 여러 레코드를 검색하더라도 매번 같은 블록을 읽어와야 함
6) **클러스터링 인덱스 + 비교**
   - 이상, 초과의 경우 인덱스를 통해 첫 번째 튜플을 찾고 파일 끝까지 스캔하여 결과를 찾음
   - 이하, 미만의 경우 첫 번째 튜플부터 최대를 만족하는 튜플까지 스캔하여 결과를 찾음, 인덱스 불필요
7) **보조 인덱스 + 비교**
   - 조건을 만족하는 인덱스에 해당하는 레코드를 매번 불러와야 함
   - 레코드의 수가 큰 경우 선형 검색보다 느릴 수 있음
   - PostgreSQL에서는 튜플을 바로 가져오는 대신에 존재하는 블록을 비트맵에 1로 표시하고 해당 블록만 스캔하는 **비트맵 인덱스 스캔 방식**을 사용
     * 최상의 경우 훨씬 빠름
     * 최악의 경우(모든 블록을 확인해야 하는 경우) 선형 검색, 보조 인덱스 스캔보다 느림
8) **하나의 인덱스를 사용한 논리곱 선택 연산**  
   (1) 인덱스를 사용할 수 있는 속성을 포함하는 조건이 있는지 결정  
   (2) 얻은 레코드들 중 남아 있는 조건을 만족하는 레코드가 있는지 테스트
9) **복합 인덱스를 이용한 논리곱 선택 연산**  
   - 논리곱과 일치하는 복합 인덱스가 있는 경우 바로 결과를 얻을 수 있음
10) **식별자의 교집합을 이용한 논리곱 선택 연산**  
    (1) 각각의 조건을 만족하는 튜플의 포인터를 인덱스를 스캔해서 얻음   
    (2) 각각의 조건들에 대한 결과들의 교집합을 구함
11) **식별자의 합집합을 이용한 논리합 선택 연산**  
    (1) 각각의 조건을 만족하는 튜플의 포인터를 인덱스를 스캔해서 얻음   
    (2) 각각의 조건들에 대한 결과들의 합집합을 구함
    - 논리합에서 접근 경로가 없는 조건이 하나라도 있으면 조건을 만족하는 튜플을 찾기 위해 선형 검색이 필요하므로, 가장 효율적인 방법은 인덱스를 사용하지 않고 바로 선형 검색하는 것

<br>

## 3. 정렬

<br>

### 1) 정렬이 중요한 이유
 - SQL 질의는 결과를 정렬된 형태로 얻을 수 있음
 - 조인과 같은 관계 연산은 입력 릴레이션이 정렬되어 있는 경우 효율적으로 구현 가능

<br>

### 2) 정렬 알고리즘
- 릴레이션이 메인 메모리에 모두 올라갈 수 있는 경우 : 일반적인 정렬 기법(퀵 소팅 등) 사용
- 메모리에 한 번에 올라가지 못하는 경우(최대 M개의 블록(1개는 출력 버퍼용)을 사용 가능한 경우)
  1) 여러 개의 정렬된 런을 생성
  2) 런을 합병(블록 크기만큼 출력 버퍼에 모았다가 한번에 디스크에 입력)
  3) 모두 정렬될 때까지 합병 연산을 여러 패스로 수행

<br>

## 4. 조인 연산

<br>

1) **중첩 루프 조인** : 중첩된 for문을 통해 각 튜플을 조인
   - 인덱스가 없는 등 어떤 조건에서도 사용 가능
   - 비용이 많이 듬
2) **블록 중첩 루프 조인** : 중첩된 for문을 통해 각 블록을 조인
3) 중첩 루프 조인 성능 향상 방법
   - 내부 릴레이션은 인덱스가 있는 릴레이션을 사용 -> 파일 스캔이 아닌 인덱스 스캔으로 튜플을 바로 찾을 수 있음
   - 둘 다 메모리에 한번에 적재 되면 내부 릴레이션에 더 작은 릴레이션을 사용 -> 반복 횟수 감소
   - 두 릴레이션 모두 메모리에 전부 적재될 수 없다면 외부 릴레이션에 더 작은 릴레이션 사용 -> 이 경우 외부 릴레이션의 탐색횟수가 두배이므로
   - 조인 속성이 내부 릴레이션의 키 속성인 경우 결과 발견 시 조기 중단 가능 -> 키는 유일하므로
   - 외부 릴레이션의 블록 단위를 메모리에 올릴 수 있는 최대 크기로 사용하고, 내부 릴레이션의 버퍼와 출력을 위한 충분한 공간 확보 -> 디스크 탐색 감소
   - 내부 반복문에 대해 한번은 앞쪽에서 한번은 뒤쪽에서 스캔 -> 디스크 헤드가 다시 처음으로 돌아가지 않아도 됨 + 이전에 스캔한 데이터 재사용 가능
4) **합병-조인** : 각 릴레이션마다 하나의 포인터를 활용하여 포인터를 이동하며 조인 속성에 대해 같은 값을 가지는 튜플들을 조인
   - 조인 속성 기준으로 정렬되어 있어야 함
   - 보조 인덱스를 이용하는 경우 레코드가 파일 블록에 흩어져 있을 수 있기에 정렬된 릴레이션을 보조 B<sup>+</sup> -트리인덱스의 단말 노드와 합병해서 사용
5) **해시-조인** : 각 릴레이션을 조인 속성에 대해 동일한 해시 값을 가지는 집합으로 분할 후 같은 분할 내의 튜플과만 비교
   - **구축(build)** : 크기가 더 작은 릴레이션(캐싱에 용이)을 구축 릴레이션으로 해시 인덱스를 구축
   - **탐색(prove)** : 해시 인덱스를 탐색 릴레이션 레코드와 맞는 구축 릴레이션의 레코드를 얻기 위해 사용
   - 재귀 분할 : 메모리 블록의 개수보다 릴레이션이 큰 경우 메모리에 한 번에 올라올 수 있을 때까지 분할
   - 오버플로 처리 : 해시 함수가 임의성과 균등성의 속성을 갖지 못해 치우친 경우
     1) 분할의 갯수를 증가하여 분할 크기의 기댓값을 감소
     2) 오버플로 분해 : 다른 해시 함수를 이용해 더 작게 분할
     3) 오버플로 방지 : 초기에 많은 작은 분할로 나눈 후 메모리 크기에 맞추게 합침
   - 메모리에 구축 입력을 모두 수용하지 못할 경우 구축 입력의 일부 분할을 버퍼로 사용하는 혼합 해시-조인을 사용하는 것이 효율적
6) **논리곱 조인** : 단순한 조인의 결과를 계산 후 남아있는 조건을 만족하는 튜플 탐색
7) **논리합 조인** : 단순한 조인의 결과를 계산 후 각 조인 결과의 합집합을 계산
8) **공간 데이터에 대한 조인** : 공간 인덱스를 활용하여 인덱스를 사용하는 중첩 루프 조인을 사용

<br>

## 5. 알고리즘 선택

<br>

- 단순 선택 연산은 인덱스가 있으면 인덱스 스캔, 아니면 선형 스캔을 사용
- 메모리보다 큰 릴레이션은 외부 정렬-합병 알고리즘 사용
- 자연 조인 시 인덱스가 사용 가능하면 인덱스를 사용하는 중첩 루프 조인 사용
- 자연 조인 시 릴레이션이 정렬되어 있으면 합병-조인 사용
- 자연 조인 시 등치 조인이고 인덱스가 없으며 릴레이션도 정렬되어 있지 않다면 해시-조인 사용
- 그 외 자연 조인 시 일반 중첩 루프 조인보다 블록 중첩 루프 조인을 사용

<br>

## 6. 기타 연산

<br>

1) **중복 제거**
   - 정렬 : 정렬의 결과 중복 값은 인접하므로 하나만 남겨 두고 제거
   - 해시 : 해시 인덱스를 구축하는 동안 들어 있지 않은 튜플만 포함하여 제거
   - 중복 제거는 비용이 크기에 명시적으로 요청하고 그렇지 않은 경우 중복 제거를 하지 않음
   - 릴레이션의 키 속성을 포함하는 경우 유일하므로 중복 제거가 불필요
2) **집합 연산**
   - 정렬 : 정렬 후 릴레이션을 스캔하여 결과를 얻음
   - 해시 : 분할 후 해시 인덱스를 활용
     * 합집합 : 탐색 릴레이션에서 해시 인덱스에 없는 튜플을 해시 인덱스에 추가
     * 교집합 : 탐색 릴레이션에서 해시 인덱스에 있는 튜플만 결과에 추가
     * 차집합 : 탐색 릴레이션에 있는 해시 인덱스 내 튜플을 제거
3) **외부 조인**
   - 내부 조인 결과를 임시 릴레이션에 저장 후 차집합을 계산한 후 속성을 null 값으로 채워 추가
   - 한쪽 외부 조인 : 조인 알고리즘 도중 어떤 튜플과도 조인되지 않은 외부 릴레이션 튜플에 null값을 추가해 사용
   - 완전 외부 조인 : 두 릴레이션의 합병 후 조인에 참여하지 않은 튜플에 null 값을 채운 후 결과에 추가
4) **집계** : 같은 값을 가지는 튜플을 제거하는 대신에 집계 연산을 적용, 같은 그룹의 튜플을 모두 모으기 전에 생성 시 집계 연산을 적용하면 더 효율적

<br>

## 7. 표현식의 평가

<br>

1) **실체화** : 표현식의 가장 낮은 단계 연산부터 수행하며 연산의 결과가 생성된(디스크에 쓴) 후 다음 단계 연산을 위해 사용
2) **파이프라이닝** : 하나의 연산 결과(일회용)를 파이프라인을 통해 다음 연산으로 넘겨줌
   - **요구 구동 파이프라인** : 요구가 있을 때만 연산 결과를 생성, 구현에 용이
   - **생산자 구동 파이프라인** : 연산 결과를 미리 만들고 필요 시 사용, 함수 호출이 적어 효율적, 병렬 처리 시스템에 용이
   - **파이프라인된 간선** : 파이프라이닝을 사용하는 간선
     * 파이프라인 단계에서 모든 연산자를 동시에 실행
   - **블로킹하는 간선** : 파이프라이닝을 사용하지 않는 간선
     * 입력의 모든 튜플을 검사해야 하는 연산의 경우 파이프라인된 간선을 사용할 수 없음
   - 기본 연산 파이프라인 구축해두고 이들을 연결하여 구성하는 것이 일반적
   - 임시 릴레이션을 읽고 쓰는 비용을 제거하고 질의 결과를 빠르게 생성
   - 스트림 데이터에 대한 질의(연속 질의)는 파이프라인 알고리즘을 기반으로 구현
   - 스트림 데이터에 대한 질의(연속 질의)는 블로킹 없이 꺼내와야 하므로 파이프라인 알고리즘 기반으로 구현해야 함
  
<br>

## 8. 메모리에서 질의 처리

<br>

1) **캐시 인식 알고리즘**
   - CPU 캐시의 데이터는 메모리 데이터보다 빠르게 접근 가능, 캐시 히트를 높이고 캐시 미스를 줄이는 것이 효율적
   - CPU 캐시는 데이터베이스 시스템이 아닌 컴퓨터 하드웨어 내장 알고리즘에 의해 제어
   - 정렬-합병 알고리즘에서 런의 크기를 CPU 캐시 크기로 설정하면 효율적
   - 해시-조인 구축 릴레이션에서 각각의 분할 크기를 CPU 캐시 크기로 설정하면 효율적
   - 함께 사용되는 경향이 있는 속성을 연속적으로 위치하도록 배치하면 효율적
2) **질의 컴파일** : 질의 계획을 기계어 코드 또는 중간 수준의 바이트 코드로 컴파일하면 효율적
3) **열 지향 저장소** : 몇 가지 특성만 사용하는 데이터 분석, 벡터 처리기능을 활용하는 데는 열 지향 저장소가 효율적
