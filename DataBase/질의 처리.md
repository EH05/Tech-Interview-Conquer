
# Chapter9. 질의 처리

---

## 1. 질의 처리 단계

<br>

질의 -> 파싱과 변환 -> 관계 대수 표현 -> 최적화 -> 평가 계획 -> 실행 -> 결과

<br>

1) **파싱과 변환** : 주어진 질의를 시스템 내부 표현 형태(평가 기본 단위)로 변환
   - 평가 기본 단위 : 대수 표현식 내의 연산 처리 방법(주석)을 포함한 관계 대수 표현
2) **최적화** : 질의 처리 비용을 최소화 하는 질의 평가 계획 도출
3) **평가** : 질의 수행 엔진이 계획을 수행한 후 질의에 대한 결과 반환

<br>

## 2. 질의 비용의 측정

<br>

1) 응답 시간은 실제 수행하기 전에 추정하기 어려워서 부적합
   - 버퍼의 내용에 의존하는데, 질의 최적화 단계에서 버퍼 정보를 이용할 수 없으며 이용 가능해도 고려하기 어려움
   - 다수의 디스크 사용 시 디스크 접근 분포에 의존하는데, 디스크상의 데이터 분포에 대한 자세한 정보 추정이 어려움
2) 일반적으로 전체 자원 소비(전체 디스크 접근 시간)를 최소화 하려고 함

<br>

> 디스크에서 자료 한 블록 전송 시간을 t<sub>r</sub>, 평균적인 블록 접근 시간이  t<sub>s</sub>일 때  
> b개의 블록을 전송하고, S번 임의 I/O 접근을 수행해야 한다면 질의 평가 계획 비용은
> 
> **b * <sub>r</sub> + S * t<sub>s</sub>**

<br>

## 3. 선택 연산

<br>

- **클러스터링(기본) 인덱스** : 데이터가 물리적으로 저장된 순서대로 만들어진 인덱스
- **보조 인덱스** : 데이터의 물리적 순서와 무관하게 추가로 만들어진 인덱스
  * 일반적으로 보조 인덱스에는 레코드에 대한 직접적인 포인터가 아닌 검색 키가 저장되므로 레코드에 접근하는 비용이 클러스터링 인덱스에 비해 큼

<br>

1) **선형 검색**
   - 각 파일 블록을 스캔하고 모든 레코드에 대해 선택 조건이 만족하는지 검사
   - 파일의 순서, 인덱스 여부, 선택 연산 속성과 상관없이 사용 가능
   - 일반적으로 다른 알고리즘보다 속도가 느림
2) **클러스터링 인덱스 + 키(유일)에 대한 동등 비교**
   - 인덱스에 해당하는 하나의 레코드를 바로 검색
3) **클러스터링 인덱스 + 키가 아닌 것(중복)에 대한 동등 비교**
   - 파일이 검색 키로 정렬되어 있으므로 연속적으로 저장된 레코드들을 검색
4) **보조 인덱스 + 키에 대한 동등 비교**
   - 인덱스에 해당하는 하나의 레코드를 바로 검색
5) **보조 인덱스 + 키가 아닌 속성에 대한 동등 비교**
   - 검색되는 수만큼 레코드를 매번 검색
   - 최악의 경우 선형 검색보다 느림
     * 선형 검색은 한 블록내의 여러 레코드를 검색할 때 해당 블록을 한번만 가져옴
     * 보조 인덱스의 경우 한 블록내의 여러 레코드를 검색하더라도 매번 같은 블록을 읽어와야 함
6) **클러스터링 인덱스 + 비교**
   - 이상, 초과의 경우 인덱스를 통해 첫 번째 튜플을 찾고 파일 끝까지 스캔하여 결과를 찾음
   - 이하, 미만의 경우 첫 번째 튜플부터 최대를 만족하는 튜플까지 스캔하여 결과를 찾음, 인덱스 불필요
7) **보조 인덱스 + 비교**
   - 조건을 만족하는 인덱스에 해당하는 레코드를 매번 불러와야 함
   - 레코드의 수가 큰 경우 선형 검색보다 느릴 수 있음
   - PostgreSQL에서는 튜플을 바로 가져오는 대신에 존재하는 블록을 비트맵에 1로 표시하고 해당 블록만 스캔하는 **비트맵 인덱스 스캔 방식**을 사용
     * 최상의 경우 훨씬 빠름
     * 최악의 경우(모든 블록을 확인해야 하는 경우) 선형 검색, 보조 인덱스 스캔보다 느림
8) **하나의 인덱스를 사용한 논리곱 선택 연산**  
   (1) 인덱스를 사용할 수 있는 속성을 포함하는 조건이 있는지 결정  
   (2) 얻은 레코드들 중 남아 있는 조건을 만족하는 레코드가 있는지 테스트
9) **복합 인덱스를 이용한 논리곱 선택 연산**  
   - 논리곱과 일치하는 복합 인덱스가 있는 경우 바로 결과를 얻을 수 있음
10) **식별자의 교집합을 이용한 논리곱 선택 연산**  
    (1) 각각의 조건을 만족하는 튜플의 포인터를 인덱스를 스캔해서 얻음   
    (2) 각각의 조건들에 대한 결과들의 교집합을 구함
11) **식별자의 합집합을 이용한 논리합 선택 연산**  
    (1) 각각의 조건을 만족하는 튜플의 포인터를 인덱스를 스캔해서 얻음   
    (2) 각각의 조건들에 대한 결과들의 합집합을 구함
    - 논리합에서 접근 경로가 없는 조건이 하나라도 있으면 조건을 만족하는 튜플을 찾기 위해 선형 검색이 필요하므로, 가장 효율적인 방법은 인덱스를 사용하지 않고 바로 선형 검색하는 것

<br>

## 3. 정렬

<br>

### 1) 정렬이 중요한 이유
 - SQL 질의는 결과를 정렬된 형태로 얻을 수 있음
 - 조인과 같은 관계 연산은 입력 릴레이션이 정렬되어 있는 경우 효율적으로 구현 가능

<br>

### 2) 정렬 알고리즘
- 릴레이션이 메인 메모리에 모두 올라갈 수 있는 경우 : 일반적인 정렬 기법(퀵 소팅 등) 사용
- 메모리에 한 번에 올라가지 못하는 경우(최대 M개의 블록(1개는 출력 버퍼용)을 사용 가능한 경우)
  1) 여러 개의 정렬된 런을 생성
  2) 런을 합병(블록 크기만큼 출력 버퍼에 모았다가 한번에 디스크에 입력)
  3) 모두 정렬될 때까지 합병 연산을 여러 패스로 수행

<br>

## 4. 조인 연산

<br>

1) **중첩 루프 조인** : 중첩된 for문을 통해 각 튜플을 조인
   - 인덱스가 없는 등 어떤 조건에서도 사용 가능
   - 비용이 많이 듬
2) **블록 중첩 루프 조인** : 중첩된 for문을 통해 각 블록을 조인
3) 중첩 루프 조인 성능 향상 방법
   - 내부 릴레이션은 인덱스가 있는 릴레이션을 사용 -> 파일 스캔이 아닌 인덱스 스캔으로 튜플을 바로 찾을 수 있음
   - 둘 다 메모리에 한번에 적재 되면 내부 릴레이션에 더 작은 릴레이션을 사용 -> 반복 횟수 감소
   - 두 릴레이션 모두 메모리에 전부 적재될 수 없다면 외부 릴레이션에 더 작은 릴레이션 사용 -> 이 경우 외부 릴레이션의 탐색횟수가 두배이므로
   - 조인 속성이 내부 릴레이션의 키 속성인 경우 결과 발견 시 조기 중단 가능 -> 키는 유일하므로
   - 외부 릴레이션의 블록 단위를 메모리에 올릴 수 있는 최대 크기로 사용하고, 내부 릴레이션의 버퍼와 출력을 위한 충분한 공간 확보 -> 디스크 탐색 감소
   - 내부 반복문에 대해 한번은 앞쪽에서 한번은 뒤쪽에서 스캔 -> 디스크 헤드가 다시 처음으로 돌아가지 않아도 됨 + 이전에 스캔한 데이터 재사용 가능
