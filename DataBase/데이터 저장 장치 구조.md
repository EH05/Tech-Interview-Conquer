# 데이터 저장 장치 구조

---

<br>

## 1. 데이터베이스 저장 장치 구조
- 영구적인 데이터는 일반적으로 자기 디스크 또는 SSD인 비휘발성 저장 장치에 저장된다.
- 자기 디스크와 SSD는 블록(block) 구조를 이용하는 저장 장치이다. 즉, 데이터를 블록 단위로 읽거나 쓴다.
- 이에 반해 데이터베이스는 일반적으로 블록보다 훨씬 작은 크기인 레코드(record)를 처리한다.
- 대부분 데이터베이스는 레코드를 저장하기 위한 중간 계층으로 운영체제 파일을 사용하여 하부 블록의 세부 정보를 추상화한다.
- 효율적인 접근을 보장하고 오류 발생 시 데이터의 복구가 가능하도록 하기 위해서 데이터베이스는 블록 구조를 계속 사용해야 한다.
- CPU가 데이터에 접근하려면 해당 데이터는 메인 메모리에 있어야 하지만, 영속 데이터는 자기 디스크 또는 SSD와 같은 비휘발성 저장 장치에 있어야 한다.
- 따라서 보통 메인 메모리보다 큰 데이터베이스의 경우, 데이터를 비휘발성 저장 장치에서 가져와서 갱신한 뒤에는 다시 저장 장치에 저장해야 한다.
- 특정 행의 모든 속성을 함께 저장하는 것이 아니라, 특정 열의 모든 값을 함께 저장하는 것에 기반을 둔 데이터 저장 방법은 분석 질의 처리에서 매우 잘 동작하는 것으로 밝혀졌다.
- 일부 응용 프로그램은 데이터에 매우 빨리 접근해야 하며 전체 데이터베이스를 데이터베이스 서버의 메인 메모리에 다 적재할 수 있을 만큼 충분히 작은 크기의 데이터를 가지기도 한다. 이런 경우, 전체 데이터베이스의 복사본을 아예 메모리에 보관할 수 있다.
- 메인 메모리 데이터베이스 : 인메모리 데이터 구조를 최적화한 데이터베이스
  
<br>

## 2. 파일 구성
- Database > File > Record
- 하나의 데이터베이스는 내부적으로 기반 운영체제가 관리하는 많은 다른 파일에 대응하며, 이 파일은 디스크 안에 영구적으로 저장된다.
- 파일(file)은 일련의 레코드로서, 논리적으로 구성된다.
- 블록(block)이라고 불리는 고정 길이(fixed-length) 저장 단위로 각 파일을 논리적으로 분할한다.
  - 블록은 저장 장소 할당과 데이터 전송의 단위이다.
  - 대부분의 데이터베이스는 기본으로 4~8킬로바이트의 블록 크기를 사용한다.
- 한 개의 블록은 여러 레코드(record)을 포함한다.
- 정확히 어떤 레코드 집합이 같은 블록에 있어야 하는지에 대한 결정은 물리적 데이터 구성의 형태가 한다.
- 블록보다 더 큰 레코드는 없다고 가정한다
  - 이 가정은 대부분의 데이터 처리 응용 프로그램을 고려할 때 현실적이다.
  - 이미지와 같이 블록보다 훨씬 큰 대용량의 데이터 항목은 별도로 저장한 다음, 레코드 안에 해당 데이터 항목에 대한 포인터를 저장함으로써 다룬다.
- 단일 블록은 각 레코드를 완전히 포함해야 한다.
  - 이는 어떤 레코드도 한 블록에 부분적으로 포함되거나 또 다른 레코드에 부분적으로 포함되지 않는다는 것을 의미한다.
- 관계형 데이터베이스에서 서로 다른 릴레이션의 튜플은 일반적으로 다른 크기를 가진다.
- 데이터베이스에 파일을 매핑하기 위한 두 가지 방법
  - 여러 파일을 사용하면서 주어진 파일 내에 고정 길이 레코드만 저장한다.
  - 파일을 구조적으로 저장하여 가변 길이로 레코드를 저장한다.
- 고정 길이 레코드로 구성된 파일은 가변 길이 레코드 파일보다 구현하기 더 쉽지만, 가변 길이의 경우에 더 많은 다양한 기법들을 적용할 수 있게 된다.

<br>

### 2-1. 고정 길이 레코드
- 문제점
  - 만약 블록 크기가 53의 배수가 되지 않는다면 몇몇 레코드는 블록 경계를 넘게 된다
    - 즉, 레코드 일부분은 어떤 블록에 저장되고 나머지 부분은 다른 블록에 저장될 것이므로 해당 레코드를 읽거나 쓰기 위해서는 두 블록에 모두 접근해야 한다.
    - 이를 피하려면 한 블록에 완전히 채울 수 있는 만큼의 블록만 레코드를 할당해야 한다. (남은 바이트는 사용하지 않은 채 남김)
  - 레코드를 삭제하기가 어렵다
    - 삭제할 레코드가 차지하는 공간은 그 파일의 다른 레코드로 채우거나, 그 공간을 무시할 수 있도록 레코드를 삭제했다는 표시를 해야 한다.
- 레코드의 삭제
  - 한 레코드를 삭제할 때 이 레코드 뒤에 있는 모든 레코드를 바로 전 레코드가 차지한 공간으로 이동시킨다.
    - 이 방법에서는 많은 수의 레코드가 이동해야 할 수 있기 때문에, 삭제한 레코드가 있었던 공간에 파일의 마지막 레코드를 단순히 이동하는 게 더 쉬울 수 있다.
    - 삭제한 레코드가 있었던 빈 곳, 즉 자유 공간을 채우기 위해 레코드를 이동하게 되면 부차적인 블록 접근이 필요하기에 바람직하지 않다.
  - 삭제한 레코드가 있었던 공간을 비워 둔 채, 재사용하기 전 다음에 삽입할 레코드를 기다리게 한다.
    - 이용 가능 공간을 찾기가 어렵기 때문에, 삭제한 레코드를 표시하는 것만으로는 충분하지 않다.
  - 자유 리스트(free list)를 사용한다.
    - 파일의 앞부분에 일부 바이트를 할당해 파일 헤더(file header)를 만들어서, 해당 파일에 대한 다양한 정보를 저장한다.
    - 여기에 삭제된 첫 번째 레코드의 주소를 저장하고, 이 레코드를 사용해서 이용 가능한 두 번째(즉 다음) 레코드의 주소를 저장하고, …이런 식으로 계속해 나가면 된다.
    - 이렇게 저장한 레코드 주소는 레코드의 위치를 가리키므로 해당 주소를 포인터(pointer)로 생각할 수 있으며, 이 삭제한 레코드는 연결 리스트(linked list)를 형성한다.
    - 이는 종종 자유 리스트(free list)로 언급하기도 한다.
- 고정 길이 레코드에서는 삭제한 레코드가 이용할 수 있는 공간은 정확하게 새로운 레코드를 삽입하는 데 필요한 공간이 된다.
- 따라서 고정된 길이의 레코드를 저장한 파일의 삽입과 삭제는 구현이 간단하다.
- 그러나 가변 길이 레코드를 파일에 저장한다면 이런 일치가 더는 유효하지 않게 된다.
<br>

### 2-2. 가변 길이 레코드
- 데이터베이스 시스템에서 가변 길이 레코드(variable-length record)가 필요한 몇 가지 상황이 있다.
  - 파일 내에 여러 레코드 유형의 존재
  - 가변 길이 필드의 존재 (e.g., varchar)
  - 배열 혹은 다중 집합(multiset)과 같은 반복적인 필드를 포함하는 레코드 유형의 존재
- 가변 길이 레코드를 구현하기 위한 다양한 기법이 존재하며, 이들은 아래의 두 가지 서로 다른 문제를 해결해야 한다.
  - 속성이 가변 길이인 경우에도 개별 속성을 쉽게 추출할 수 있는 방식으로 하나의 레코드를 표현하는 방법
  - 블록 내의 레코드를 쉽게 추출할 수 있도록 블록 내에 가변 길이 레코드를 저장하는 방법
- 가변 길이의 속성을 지닌 레코드의 표현은 일반적으로 두 부분으로 구성된다.
  - 구조가 같은 릴레이션의 모든 레코드에 대해 같은 고정 길이 정보를 갖는 처음 부분
    - 고정 길이 속성에 해당 값을 저장하는 데 필요한 많은 수의 바이트마늠을 해당 고정 길이 속성에 할당한다.
  - 가변 길이 속성의 내용으로 구성된 그다음 부분
    - 레코드의 처음 부분에서 [offset, length]의 쌍으로 표현된다.
      - offset : 레코드 내의 속성이 시작되는 부분을 위한 데이터
      - length : 가변 길이 속성의 바이트의 길이 (size of data)
- 널 비트맵, null bitmap : 어떤 레코드의 속성이 null 값을 가지는지를 나타내는 널 비트맵(null bitmap)의 사용도 볼 수 있다.
  - 일부 표현에서 레코드의 시작 부분에 널 비트맵을 저장하고, null인 속성을 위해 값이나 offset, length와 같은 데이터를 전혀 저장하지 않는다.
  - 이런 표현에서는 레코드의 속성을 추출하기 위한 여분의 작업 비용에서 저장 장치의 공간을 절약하게 되므로, 대부분의 필드가 null 값을 갖는 레코드를 사용하는 여러 응용 프로그램에 특히 유용하다.
- 슬롯 페이지 구조, slotted-page structure : 블록 내의 레코드를 구성하는 데 흔히 사용된다.
  - 각 블록의 시작에는 다음의 정보를 저장하는 헤더가 있다.
    - 헤더가 있는 레코드 엔트리의 수
    - 블록에서 빈 곳의 끝
    - 각 레코드의 위치와 크기를 포함하고 있는 엔트리 배열
  - 레코드의 삽입
    - 실제 레코드는 블록의 끝에서부터 인접하게(contiguously) 할당되며, 블록에서 빈 곳은 헤더 배열에 있는 마지막 엔트리와 첫 번째 레코드 사이에서 연속적이다.
    - 어떤 한 레코드를 삽입하면 빈 곳 끝에 이 레코드를 위한 공간을 할당하고, 이 레코드의 크기와 위치를 포함하는 엔트리를 헤더에 추가한다.
  - 레코드의 삭제
    - 레코드를 삭제하면 해당 레코드가 차지하고 있던 공간을 비우고, 관련 엔트리를 삭제한 상태(예를 들어, 크기는 -1로 표시)로 명시한다.
    - 삭제한 레코드 앞쪽에 있는 레코드를 이동한다. 이를 통해 삭제한 레코드가 차지하고 있었던 공간이 빈 곳이 되어, 모든 빈 곳은 다시 헤더 배열의 마지막 엔트리와 첫 번째 레코드 사이에 있게 된다.
    - 특징
      - 헤더에 있는 빈 공간의 끝을 가리키는 포인터를 상황에 맞게 갱신해야 한다.
      - 블록의 크기가 제한되어 있으므로 레코드를 이동하는 비용은 크게 들지 않는다. 블록의 크기는 보통 4~8킬로바이트다.
      - 레코드를 직접 가리키는 포인터는 없도록 해야 하며, 포인터는 레코드의 실제 위치를 포함하고 있는 헤더 안에 있는 엔트리를 가리키도록 해야 한다.
<br>

### 2-3. 대형 객체 저장 방법
- 데이터베이스는 디스크 블록보다 훨씬 큰 데이터를 종종 저장한다.
- 대부분의 관계형 데이터베이스는 내부적으로 한 레코드의 크기가 한 블록의 크기를 넘지 않도록 제한한다.
- 해당 대형 객체(large object)는 레코드의 다른 소형 속성과는 별도로 저장하며, 대형 객체에 대한 논리 포인터를 해당 객체를 포함하는 레코드에 저장한다.
- 대형 객체를 저장하는 방법에는 두 가지가 존재한다.
  - 데이터베이스가 관리하는 파일 시스템 영역의 파일로 저장한다.
  - 데이터베이스가 저장하고 관리하는 파일 구성으로 저장한다.
    - 데이터베이스 내 대형 객체를 B+-tree 파일 구성을 사용해서 선택적으로 표현할 수 있다.
    - B+-tree 파일 구성은 그 객체 내의 임의 위치에 대한 효율적인 접근을 가능하게 한다.
- 성능 이슈
  - 대형 객체를 데이터베이스 인터페이스를 통해서 접근하는 것이 효율적인가?
  - 데이터베이스 백업의 크기 증가
    - 많은 기업이 주기적으로 데이터베이스 덤프(dump), 즉 데이터베이스의 백업 복사본을 만드는데 데이터베이스에 대형 객체를 저장하면 데이터베이스 덤프의 크기가 매우 증가할 것이다.
- 해결법
  -  많은 응용 프로그램은 크기가 매우 큰 객체를 데이터베이스 외부의 파일 시스템에 저장한다. 이럴 때 응용 프로그램은 파일 이름(일반적으로 파일 시스템에서 경로)을 데이터베이스 내 레코드의 속성으로 저장할 수 있다.
  -  하지만 이렇게 하면 문제들이 또다시 발생하게 된다.
    - 데이터베이스의 파일 이름이 존재하지 않는 파일을 가리키게 되며, 파일이 삭제되었기 때문에 외래 키 제약 조건을 위반하는 형태가 된다.
    - 데이터베이스 권한 제어는 파일 시스템에 저장된 데이터에는 적용되지 않는다.
  - 따라서 일부 데이터베이스는 데이터베이스와의 파일 시스템 통합을 제공한다.
    - 제약 조건을 충족하는지를 확인하고 데이터베이스 접근 권한을 적용하도록 한다.
    - 즉, 파일 시스템 인터페이스와 데이터베이스 SQL 인터페이스 모두에서 파일에 접근할 수 있는 것이다.
<br>

## 3. 파일에 레코드를 구성하는 방법
- 힙 파일 구성, Heap file organization
- 순차 파일 구성, Sequential file organization
- 다중 테이블 군집 파일 구성, Multitable clustering file organization
- B+-트리 파일 구성, B+-tree file organization
- 해싱 파일 구성, Hashing file organization

<br>

### 3-1. 힙 파일 구성
- 레코드는 릴레이션에 해당하는 파일의 어디에나 저장될 수 있다.
- 파일 안에 레코드를 위한 공간만 있다면 임의의 레코드는 어디든지 놓일 수 있으며, 레코드의 순서는 없다.
- 레코드의 삽입
  - 레코드를 파일에 삽입할 때, 항상 파일의 끝부분에 추가하도록 할 수 있다.
  - 그러나 레코드를 삭제하면 만들어진 빈 곳을 사용하여 새 레코드를 저장하는 것이 더 좋다.
- 여유 공간 맵, free-space map 
  - 대부분 데이터베이스는 여유 공간 맵(free-space map)이라고 하는 공간 효율적 데이터 구조를 사용하여 레코드를 저장할 여유 공간이 있는 블록을 추적한다.
  - 여유 공간 맵은 릴레이션의 각 블록에 대해 한 개의 엔트리를 포함하는 배열로 흔히 나타낸다.
  - 각 엔트리는 비율 f를 표현하는데, 이는 최소 비율 f만큼이 해당 블록 공간에 비어 있어야 한다는 것을 뜻한다.
  - 레코드를 삽입, 삭제 또는 그 크기를 변경할 때마다 엔트리 값에 영향을 줄 만큼 점유 비율이 변경되면 여유 공간 맵에서 엔트리를 갱신한다.
  - 데이터베이스는 주어진 크기의 새 레코드를 저장할 블록을 찾기 위해, 여유 공간 맵을 스캔하여 해당 레코드를 저장할 충분한 여유 공간이 있는 블록을 찾는다. 만약 적당한 블록이 없다면 릴레이션에 새로운 블록을 할당한다.
- 2계층 여유 공간 맵 
  - 여유 공간이 충분한 블록을 찾는 작업의 속도를 높이기 위해 등장
  - 2단계 여유 공간 맵은 기존의 여유 공간 맵의 n개 엔트리 중 최댓값만을 저장하는 것으로 구현할 수 있다.
  - 2단계 여유 공간 맵에서 충분한 여유 공간을 가진 적절한 엔트리가 발견되면,
  - 기본 여유 공간 맵에서 해당하는 엔트리들을 검사하며 여유 공간이 충분한 블록을 찾으면 된다.
  - 매우 큰 릴레이션을 다루기 위해 같은 아이디어를 사용하여 2계층 이상의 여유 공간 맵을 만들 수 있다.
- 여유 공간 맵의 갱신
  - 맵의 엔트리를 갱신할 때마다 여유 공간 맵을 디스크에 쓰는 것은 비용이 많이 들 수 있다.
  - 따라서 여유 공간 맵을 주기적으로 쓰게 되는데, 이로 인해 디스크의 여유 공간 맵이 최신이 아닐수도 있다.
  - 즉, 여유 공간 맵은 블록에 여유 공간이 없을 때도 여유 공간이 있다고 할 수 있으며, 이 오류는 블록을 가져올 때 감지가 된다. 이는 여유 공간 맵에서 추가로 검색하여 해결할 수 있다.
  - 반면에 여유 공간 맵은 블록에 여유 공간이 없다고 할 수도 있는데, 이를 해결하기 위해 릴레이션을 주기적으로 스캔하고 여유 공간 맵을 다시 계산하여 디스크에 기록한다.
<br>

### 3-2. 순차 파일 구성
- 레코드의 효율적인 처리를 위해 일부 검색 키(search key)를 기반으로 정렬한 순서로 순차 파일(sequential file)을 설계한다.
- 검색 키 : 특정 속성이나 속성들의 집합으로, 정렬의 기준이 된다.
  - 반드시 주 키이거나 수퍼 키일 필요는 없다.
  - 각 레코드는 다음 레코드를 검색 키의 순서로 포인터를 통해 연결한다.
- 레코드를 삽입하고 삭제한 대로 물리적 순서를 유지하기는 어렵다.
- 한 번의 삽입이나 삭제 때문에 많은 레코드를 이동하는 것은 비용이 많이 들기 때문이다.
- 레코드의 삭제는 포인터 체인을 이용하여 관리할 수 있다.
- 검색 키 순서로 볼 때 삽입할 레코드 바로 앞에 위치하는 레코드를 파일에서 찾는다.
  - 찾은 레코드와 같은 블록 내에 빈 레코드(즉 삭제한 후 빈 공간)가 있다면 거기에 새로운 레코드를 삽입한다.
  - 그렇지 않다면 오버플로 블록(overflow block)에 새로운 레코드를 삽입한다. 어느 경우든, 레코드를 검색 키 순서로 연결하기 위해 포인터를 조정한다.
- 파일의 재구성
  - 상대적으로 오버플로 블록에 저장할 필요가 있는 레코드가 거의 없다면 위의 방법은 잘 동작한다.
  - 하지만 검색 키 순서와 물리적 순서 사이의 일치를 시간이 지남에 따라 완전히 잃어버릴 수가 있어, 이 경우 순차적인 처리가 훨씬 비효율적으로 될 수 있다.
  - 이 시점에서는 다시 물리적으로 순차적인 순서가 되도록 파일을 재구성(reorganized)해야 한다.
    - 재구성 작업은 비용이 많이 든다.
    - 이 작업은 시스템 작업량이 낮을 때 해야 한다.
    - 재구성이 필요한 빈도는 새로운 레코드의 삽입 빈도에 따라 다르다.
  - B+-트리 파일 구성은 삽입, 삭제 및 갱신이 많이 일어날 때도 비용이 많이 드는 재구성 없이 효율적인 정렬 접근이 가능하다.
<br>

### 3-3. 다중 테이블 군집 파일 구성
- 많은 데이터베이스 시스템은 각 릴레이션을 독립된 파일, 또는 독립된 파일 집합에 저장한다. 그렇지만 단일 블록에 여러 릴레이션을 저장하는 것이 유용할 수 있다.
- 다중테이블 군집은 서로 연관성이 높은 여러 테이블의 튜플을 하나의 물리적 파일(또는 연속적인 블록 집합)에 함께 저장하는 기법이다.
- 주로 공통 조인 속성을 기준으로 테이블들을 군집화하여, 조인 연산 시 관련 튜플들이 같은 블록이나 인접한 블록에 위치하도록 한다.
- 조인 성능 최적화: 여러 테이블이 자주 조인될 때, 물리적 위치가 가까우면 디스크 I/O가 감소되어 조인 작업의 처리 속도가 향상된다. 한 블록을 읽을 때 여러 테이블의 관련 레코드를 한꺼번에 불러올 수 있어, 불필요한 디스크 접근을 줄입니다.
- 군집 키 : 함께 저장되는 레코드를 정의하는 속성
<br>

### 3-4. 분할
- 분할은 하나의 큰 테이블이나 파일을 관리하기 쉬운 여러 작은 단위(파티션)로 나누어 저장하는 기법이다.
- 분할을 통해 특정 조건에 맞는 파티션만 접근하거나, 병렬 처리를 이용해 I/O 성능과 관리 효율성을 높일 수 있습니다.

<br>

## 4. 데이터 사전 저장소
- 데이터 사전 저장소(또는 시스템 카탈로그)는 데이터베이스에 저장된 모든 객체에 관한 메타데이터를 체계적으로 관리하는 중앙 저장소입니다.
- 정보의 종류
  - 릴레이션의 이름
  - 각 릴레이션의 속성의 이름
  - 속성의 도메인과 길이
  - 데이터베이스에 대해 정의한 뷰의 이름과 이 뷰에 대한 정의
  - 무결성 제약 조건(예: 키 제약 조건)
  - 시스템 사용자에 대한 정보
    - 사용자의 이름, 사용자의 기본 스키마, 사용자를 인증하기 위해 사용되는 비밀번호 혹은 다른 정보
    - 각 사용자의 권한에 대한 정보
- 축소형 데이터베이스를 구성한다.
- 표현을 중시하기에 정규화보다는 접근 효율성을 우선시 한다.
- 시스템 메타데이터를 자주 접근하기 때문에 데이터베이스 시스템 자체가 효율적으로 접근이 가능한 것이다.

<br>

## 5. 버퍼 관리자
데이터베이스 버퍼는 디스크 I/O 비용을 줄이고 전체 시스템 성능을 높이기 위해 메인 메모리를 활용하여 데이터 페이지를 임시로 저장하는 캐시 역할을 수행한다.
버퍼 공간의 할당을 책임지고 있는 서브시스템을 버퍼 관리자라 한다.

<br>

### 5-1. 버퍼 관리자
- 데이터베이스 시스템 내의 프로그램은 디스크로부터 블록을 가져울 필요가 있을 때 버퍼 관리자를 호출한다.
- 버퍼 관리자는 해당 블록이 버퍼에 있다면 메인 메모리의 블록 주소를 요청한 프로세스에 전달한다.
- 없다면 버퍼에 저장하기 위한 공간을 할당하고 디스크로부터 요구된 블록을 읽고 요청한 프로세스에 전달한다.
<br>

#### 5-1-1. 버퍼 교체 전략
- 버퍼 풀이 가득 찼을 때 어떤 페이지를 메모리에서 내보내고 새로운 페이지를 로드할지 결정하는 전략
- 대부분의 운영체제는 LRU(Least Recently Used)를 사용한다.
<br>

#### 5-1-2. 버퍼에 고정된 핀 블록
- 블록을 버퍼로부터 들고오면 데이터베이스 프로세느느 버퍼 메모리에서 해당 블록의 내용을 읽을 수 있다.
- 블록을 읽는 상황에서 해당 블록을 제거하고 교체하면 큰 블록 손상이 일어난다.
- 블록을 고정시키는 핀 연산이 등장한다
  - 하나의 데이터 페이지가 현재 사용 중이면 해당 페이지는 “핀”되어 교체 대상에서 제외됩니다.
- 각 페이지에 핀 카운트를 유지하여, 동시에 여러 트랜잭션이 같은 페이지를 참조하는 경우에도 안전하게 보호하며, 작업이 완료되면 핀을 해제하여 교체 후보로 다시 포함시킨다.
<br>

#### 5-1-3. 버퍼에 대한 공유 및 독점적 잠금
- 페이지에서 추가하거나 삭제하느 프로세스는 페이지 내용을 이동할 필요가 있다.
- 이 기간에는 어떤 프로세스도 페이지의 내용을 읽으면 안된다.
- 버퍼에 대한 공유 및 독점적 잠금이란 동시 다발적인 접근 환경에서 데이터 일관성과 무결성을 보장하기 위해, 버퍼 내의 페이지에 대해 읽기(공유)와 쓰기(독점) 잠금을 적용하는 메커니즘
- 잠금의 규칙
  - 임의의 수의 프로세스가 동시에 어떤 블록에 대한 공유 잠금을 가질 수 있다.
  - 한 번에 하나의 프로세스만 독점적 잠금을 얻을 수 있으며, 더 나아가 프로세스가 독점적 잠금을 가질 때 어떤 다른 프로세스도 블록에 대한 공유 잠금을 가질 수 없다. 따라서 어떤 다른 프로세스가 버퍼 블록에 대해 잠금을 가지지 않는 경우에만 독점적 잠금을 부여할 수 있다.
  - 블록이 이미 공유 또는 독점적 모드로 잠금 상태일 때 프로세스가 독점적 잠금을 요청하면 이전 의 모든 잠금이 해제될 때까지 해당 블록에 대한 요청을 보류 상태로 유지한다.
  - 블록이 잠금 상태가 아니거나 이미 공유 잠금인 상태에서 프로세스가 해당 블록에 대한 공유 잠금을 요청하면 그 공유 잠금은 허용된다. 그러나 또 다른 프로세스가 독점적 잠금을 가지는 경우 독점적 잠금을 해제한 후에만 공유 잠금을 부여할 수 있다.
- 짐금 획득 및 해제 경우
  - 블록에 대한 작업을 수행하기 전에 프로세스는 앞서 본 것처럼 블록을 핀해야 한다. 잠금은 이후에 획득됨며 블록을 언핀 하기 전에 자금 해제해야 한다.
  - 버퍼 블록에서 데이터를 읽기 전에 프로세스는 블록에 대한 공유 잠금을 얻어야 한다. 데이터 읽기가 완료되면 프로세스는 잠금을 해제해야 한다.
  - 버퍼 블록의 내용을 갱신하기 전에 프로세스는 블록에 대한 독점적 잠금을 얻어야 한다. 갱신이 완료된 후 잠금을 해제해야 한다.
<br>

#### 5-1-4. 블록의 출력
- 다른 블록에 버퍼 공간이 필요한 경우에만 블록을 출력할 수 있다.
- 버퍼 공간이 필요할 때까지 기다리지 않고 그러한 필요에 앞서 갱신한 블록을 사용하는 것이 좋다.
- 버퍼에 공간이 필요할 때 이미 기록된 블록은 현재 핀 되어 있지 않은면 제거될 수 있다.
<br>

#### 5-1-5. 블록의 강제 출력
- 디스크상의 어떤 데이터가 일관된 상태에 있게 하려고 블록을 디스크에 다시 쓸 필요가 있는 상황
- 강제 출력은 Logging과 같은 기법과 연계되어, 트랜잭션 완료 전에 관련 페이지와 로그가 안전하게 디스크에 기록되도록 함으로써 장애 발생 시 일관된 복구 상태를 제공하는 역할을 한다.
<br>

### 5-2. 버퍼 교체 전략
- 교체 목적 : 버퍼 풀이 가득 찼을 때, 새로운 페이지를 로드할 공간을 만들기 위해 어떤 페이지를 내보낼지를 결정하는 것으로 가장 효율적인 방법으로 교체해야 한다.
- LRU 버퍼 교체 방법 : 가장 오랫동안 사용되지 않은 페이지를 교체 대상으로 선택
  - 최근에 사용된 페이지는 앞으로도 재사용될 가능성이 높다는 전제 하에, 사용하지 않은 오래된 페이지를 우선적으로 내보낸다.
- MRU 버퍼 교체 방법 : 가장 최근에 사용된 페이지를 교체 대상으로 선택하는 전략입니다.
  - 특정 상황에서는 최근에 사용된 페이지가 이미 작업을 마쳤고, 즉시 재사용되지 않을 가능성이 높다고 보고, 이 페이지를 제거한다.
- 이상적인 데이터베이스 블록 교체 방법이 되기 위해서는 어떤 연산을 수행하고 있고, 어떤 연산을 앞으로 수행할지와 같은 데이터베이스 연산에 대한 지식이 필요하다.
<br>

### 5-3. 쓰기 및 복구의 재정렬
- 데이터베이스의 쓰기 작업을 재정렬하여 디스크에 기록할 때 효율성을 극대화하고, 장애 발생 시 복구 작업을 빠르고 일관되게 수행할 수 있도록 지원
- 버퍼를 사용하면 나중에 쓰기가 수행된 순서와 다른 순서로 메모리 내에서 데이터 쓰기를 수행한 후 나중에 디스크에 출력할 수 있다.
- 파일 시스템 일관성 검사 (File System Consistency Check) : 시스템이 예기치 않은 장애나 크래시 이후, 디스크에 기록된 데이터와 메타데이터의 일관성을 점검하고 복구하기 위한 절차
  - 비휘발성 RAM을 활용한 파일 시스템 검사 : 비휘발성 RAM(NVRAM)을 이용하면, 메모리 내에 임시 저장된 데이터나 메타데이터를 보존할 수 있어, 장애 후 파일 시스템 상태를 보다 빠르게 복원할 수 있습니다.
  - 로그 디스크를 바탕으로 하는 검사 : 별도의 로그 전용 디스크에 기록된 로그 데이터를 활용하여, 파일 시스템의 최신 상태나 변경 이력을 확인함으로써 복구 작업을 보다 체계적으로 수행할 수 있습니다.
    - 로그 디스크는 주 데이터 디스크와 분리되어 있어, 장애 시 로그의 무결성이 유지됩니다.
    - 복구 시, 로그에 기록된 순차적인 변경 내역을 재생(replay)하거나 롤백(rollback)하여, 파일 시스템의 일관된 상태를 복원합니다.
    - 이 방식은 전체 파일 시스템을 스캔하는 대신, 로그에 기록된 정보만 활용하여 보다 타겟화된 복구를 수행할 수 있게 해 줍니다.
- 저널링 파일 시스템 : 모든 메타데이터 변경 및 일부 데이터 변경을 별도의 “저널(또는 로그)”에 먼저 기록한 후, 실제 데이터 영역에 적용하는 방식입니다.
  - 별도의 로그 디스크 없이도 구현할 수 있으며 데이터와 로그를 같은 디스크에 보관할 수 있다.
  - 빠른 복구: 장애 발생 후, 저널에 기록된 변경 내역을 재생함으로써 전체 파일 시스템을 일일이 검사하지 않고도 신속하게 일관된 상태로 복구할 수 있습니다.
  - 데이터 무결성: 로그와 데이터의 순서 보장을 통해, 장애 도중 발생할 수 있는 부분적 기록이나 불일치를 최소화합니다.
  - 일관성 보장: 커밋 전까지는 변경 내용을 저널에만 기록함으로써, 장애 시 미완료된 작업을 감지하고 적절한 롤백을 수행할 수 있습니다.
    
<br>

## 6. 열 지향 저장소
- 열지향 저장소는 전통적인 행(Row) 기반 저장 방식과 달리, 테이블의 각 열을 독립적인 저장 단위로 구성한다.
- 장점 :
  - 감소한 I/O : 쿼리에서 필요한 컬럼만 읽어들이므로, 전체 행을 읽어오는 행 저장소에 비해 디스크 I/O가 크게 줄어듭니다. 읽기 작업의 효율성이 향상되어, 대규모 데이터 집합에 대해 빠른 질의 응답이 가능합니다.
  - 향상된 CPU 캐시 성능 : 동일한 데이터 타입과 값들이 연속적으로 저장되므로, CPU 캐시의 지역성이 개선된다. 캐시 미스를 줄이고, 데이터 처리 시 메모리 접근 속도를 높여 전반적인 처리 성능을 높인다.
  - 개선된 압축 : 같은 열 내의 값들이 유사한 특성을 보이는 경우가 많아, 효과적인 압축 알고리즘을 적용할 수 있다. 저장 공간이 절감되고, 디스크에서 읽어오는 데이터의 양이 줄어들어 I/O 성능 향상에도 기여
  - 벡터 처리 : 열 단위로 데이터를 한 번에 처리하는 벡터화 기법을 적용할 수 있다. CPU에서 병렬 처리 효율을 높이고, 연산 성능을 개선한다.
- 단점 :
  - 튜플 재구성 비용 : 열 단위로 저장된 데이터를 행 단위의 튜플로 다시 조합해야 하는 경우, 재구성 오버헤드가 발생, 전체 행을 필요로 하는 질의나 트랜잭션 처리 시 추가적인 계산 비용이 증가
  - 튜플 삭제 및 갱신 비용 : 하나의 튜플에 대해 여러 열에 분산되어 있는 데이터를 각각 업데이트하거나 삭제하는 작업은, 행 저장 방식보다 복잡하고 비용이 높다.
  - 압축 해제 비용 : 압축된 데이터를 읽어 처리할 때, 압축 해제 작업이 필요하며 이 과정의 비용은 크다.
- 하이브리드 행/열 저장소 : 하이브리드 행/열 저장소는 행 저장소와 열 저장소의 장점을 모두 활용할 수 있도록 설계된 구조

<br>

## 7. 메인 메모리 데이터베이스의 저장 구조
- 현재의 메인 메모리는 크기가 충분히 크고 가격도 저렴하여 버퍼에 많은 야으이 메모리를 할당하여 사용할 수 있다.
- 메인 메모리 데이터베이스 : 모든 데이터가 메모리에 상주하는 데이터베이스
  - 버퍼 관리자를 사용하지 않음
  - 디스크 기반 DBMS와 달리, 메인 메모리 데이터베이스는 데이터의 주 저장소를 메모리로 사용하여 I/O 지연을 최소화하고 빠른 데이터 접근 및 처리를 실현한다.
  - 메모리에 저장된 데이터를 보호하기 위해 로그 기록, 체크포인트 및 백업 등의 작업만 디스크에 수행하며, 주 작업은 메모리에서 처리된다.
- 레코드 접근 비용 : CPU의 캐시 성능과 메모리 대역폭에 의존하며, 디스크 기반 시스템 대비 극히 낮은 비용으로 빠른 데이터 검색과 처리를 가능
- 슬롯 페이지 구조를 사용하지 않고 메인 메모리에 직접 레코드를 할당한다.
  - 레코드 할당과정에서 메모리 단편화가 일어날 수 있다.
  - 주기적으로 메모리 압축이 필요하다.
- 릴레이션에 대한 데이터 추가가 있는 경우 연속적인 할당을 보장하기 위해 기존 데이터를 재 할당해야 한다.
  - 오버헤드 방지를 위해 간접테이블을 활용하여 물리적 배열에 대한 포인터를 저장한다.
