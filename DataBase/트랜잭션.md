# 트랜잭션

트랜잭션 : 하나의 논리적 작업 단위를 이루는 연산의 집합
데이터베이스의 역할 : 오류가 발생하더라도 트랜잭션이 올바른 수행을 하도록 보장해야 한다.
  - 트랜잭션의 올바른 수행 : 트랜잭션을 구성하는 연산이 모두 실행되거나 하나도 실행되지 않는것

---

<br>

## 1. 트랜잭션 개념

- 트랜잭션(transaction) : 다양한 데이터 항목에 접근하고 갱신하는 프로그램 수행의 단위
  - 구성 요소 : begin transaction + 실행되는 연산 + end transaction
  - 특성 :
    - 원자성(Atomicity) : '전부 아니면 전부(all-or-none)', 사용자에게 하나의 나눌 수 없는 단위처럼 보임(So 전부 실행되거나 전부 실행되지 않아야 한다. 나눌 수 없으므로)
    - 일관성(Consisteny) : 고립 상태에서 트랜잭션 수행이 데이터베이스의 일관성을 보존해야 한다.
    - 고립성(Isolation) : 동시에 수행되는 다른 데이터베이스 명령어의 영향을 받지 않고 올바르게 수행되어야 한다.
    - 지속성(Durability) : 트랜잭션의 실행 결과는 시스템 장애와 상관없이 영구적으로 반영되어야 한다.

<br>

## 2. 간단한 트랜잭션 모델

- 상황 : 계좌에 접근하고 갱신하는 간단한 은행 시스템
  - read(X) : 데이터 항목 X를 데이터베이스로부터 읽어서 read 연산을 수행하는 트랜잭션의 메인 메모리 버퍼 X라는 변수에 저장
  - write(X) : 메인 메모리 버퍼에 있는 변수 X의 값을 데이터베이스 X에 저장
- T1 : 계좌 A에서 계좌 B로 50$ 달러 이체하는 트랜잭션
  > T1:    
    read(A);   
    A:= A - 50;   
    write(A);   
    read(B);   
    B:= B + 50;   
    write(B);   
  - 일관성 : 계좌 A와 B의 잔액의 합이 트랜잭션 이후에도 동일해야 한다.
  - 원자성 : 만약 write(A)와 write(B) 사이에 실패가 발생한다면 A의 잔액만 손실보는 형태가 일어난다.
    - 해결책 :
      1. 트랜잭션이 wirte 연산을 하는 데이터의 예전 값을 계속 추적한다.(= 로그로 기록)
      2. 정상적으로 종료되지 않는다면 로그를 사용해 이전값으로 복구한다.
  - 지속성 : 트랜잭션이 성공적으로 종료된 이후에는 더이상 계좌A와 계좌B의 변동이 있어서는 안된다.
    - 데이터 손실을 방지하는 기법 :
      1. 트랜잭션이 수행한 갱신을 트랜잭션이 완료되기 전에 디스크에 기록한다.
      2. 데이터베이스 시스템이 시스템 오류 후에 재시작되었을 때, 실패한 트랜잭션이 갱신한 데이터를 다시 복수할수 있을 만큼 충분한 정보를 디스크에 기록한다.
  - 고립성 : 만약 write(A)와 write(B) 사이에 계좌A와 계좌B의 합을 구하는 연산이 있다면 고립성이 위배된다.
    - 해결책 :
      1. 순차적으로 트랜잭션을 실행한다.

<br>

## 3. 저장 장치의 구조
- 원자성과 지속성을 보장하기 위해서는 데이터베이스의 저장 장치 구조를 이해해야 한다.
- 저장매체는 상대적인 속도와 용량, 그리고 실패로부터의 복구 능력에 따라 구분된다.
- 휘발성 저장 장치(Volatile storage) : 
  - 특징
    1. 시스템 장애 시 많은 경우 손실된다.
    2. 메모리 자체의 속도가 빠르고 휘발성 저장 장치 내의 모든 데이터는 직접 접근이 가능하여 속도가 매우 빠르다.
  - E.g. 메인 메모리, 캐시 메모리
- 비휘발성 저장 장치(Non-volatile storage) : 
  - 특징
    1. 시스템 장애 시에도 보존된다.(데이터 손실을 일으키는 장애가 일어나기도 한다.)
    2. 랜덤 접근을 하여 휘발성 저장 장치에 비해 속도가 많이 느리다.
  - E.g. 2차 저장 장치(자기 디스크, 플래시 저장 장치), 3차 저장 장치(광학 미디어, 자기 테이프)
- 안정 저장 장치(Stable storage) : 
  - 특징 : 이론적으로 정보는 절대 손실되지 않는다.
  - 구현 : 장애의 원인이 독립적인 여러 비휘발성 저장 장치에 정보를 복사한다.

<br>

## 4. 트랜잭션 원자성과 지속성
- 트랜잭션은 항상 성공적으로 완료되지 않고 중단(aborted)되기도 한다.
- 중단된 트랜잭션으로 인한 원복과정을 롤백(rollback)이라고 한다.
- 트랜잭션의 중단과 롤백은 로그를 유지하는 방법을 활용한다.
  - 로그 활용법 : 트랜잭션이 데이터베이스에 가한 모든 수정내용을 로그에 기록한다. 이후 데이터 베이스에 수정내용을 반영한다.
    - 로그내용 : 데이터 항목의 식별자, 데이터 항목의 이전 값 및 새로운 값
- 성공적으로 완료한 트랜잭션 : 커밋(commit)
- 트랜잭션의 영향을 취소하는 방법 : 보상 트랜잭션(compensating transaction)을 실행하는 것, 그러나 보상 트랜잭션은 데이터베이스의 역할이 아닌 사용자의 역할이다.
- 트랜잭션의 상태 : 트랜잭션은 항상 5가지 상태중 하나의 상태를 취한다.
  1. 동작(Active) : 초기 상태, 트랜잭션 실행중의 상태
  2. 부분 커밋(Partially committed) : 마지막 명령문이 실행된 후의 상태
  3. 실패(Failed) : 정상적인 실행이 더 진행될수 없는 상태
  4. 중단(Aborted) : 트랜잭션이 롤백되고 데이터베이스가 트랜잭션 실행 전 상태로 복원된 상태
  5. 커밋(Committed) : 트랜잭션이 성공적으로 완료된 상태
![트랜잭션상태다이어그램](https://blog.kakaocdn.net/dn/uuVmT/btsnaloMKSv/5iUtUMRbScEilQwshmVON1/img.png)
- 트랜잭션은 동작 상태에서 시작한다.
- 트랜잭션이 마지막 명령문을 실해아고 나면 부분 커밋 상태가 된다.
- 데이터 복구에 필요한 정보가 전부 저장되고 실행결과를 반영하면 트랜잭션은 커밋상태가 된다.
- 트랜잭션이 더는 정상적인 실행을 할수 없다면 실패 상태로 들어가고 롤백되면 중단 상태가 된다.
- 중단 상태에서 2가지의 선택지가 존재한다
  - 재시작(restart) : 하드웨어 오류시 트랜잭션 재시작
  - 강제 종료(kill) : 트랜잭션 내부에 논리적 오류 존재 또는 데이터베이스에 필요한 데이터가 없는 경우
- 관찰 가능한 외부 출력(observable external writes) : 사용자가 확인 가능한 상태로 출력(스크린, 출력, 메일보내기)
  - 출력은 항상 커밋 상태에 들어간 다음에 일어나야 한다.
  - 데이터베이스가 외부 출력과 관련된 값을 데이터베이스의 특수 테이블에 임시로 기록한 다음 트랜잭션이 커밋 상태로 들어가면 실제 외부로 출력을 수행
  - 트랙잭션의 과정을 사용자에게 보여주는것은 큰 위험성을 갖는다.

<br>

## 5. 트랜잭션 고립성
- 트랜잭션 처리 시스템은 시스템 성능 향상을 위해 동시성을 지원하지만 이는 일관성에 문제가 생길 수 있다.
- 트랜잭션이 하나씩 순차적으로 실행되도록 한다면 문제는 간단하지만 동시성의 이점이 크기에 동시성을 지원한다.
- 동시성의 이점 :
  1. 처리율과 자원 이용률 향상 : 트랜잭션은 많은 단계로 구성되어 있고 I/O작업, CPU 처리는 병렬적으로 이용가능하다. 즉 동시성을 허용하면 프로세서와 디스크가 휴식하는 시간을 줄일 수 있다.
    - 처리율 : 주어진 시간에 처리되는 트랙잭션의 수
    - 이용률 : 프로세서와 디스크의 이용률
  2. 대기 시간 감소 : 트랜잭션이 순차적으로 처리된다면 긴 트랜잭션 뒤의 트랜잭션들은 오랜 시간 대기해야 한다. 동시 수행은 지연을 줄이고 평균 응답 시간(average response time)을 줄일 수 있다.
- 동시성의 이점이 크더라도 데이터베이스의 일관성을 깨서는 안된다.
- T1 : 계좌 A에서 계좌 B로 50$ 달러 이체하는 트랜잭션
  > T1:    
    read(A);   
    A:= A - 50;   
    write(A);   
    read(B);   
    B:= B + 50;   
    write(B); 
- T2 : 계좌 A에서 계좌 B로 잔액의 10%를 이체하는 트랜잭션
  > T2:    
    read(A);   
    temp := A*0.1;
    A:= A - temp;   
    write(A);   
    read(B);   
    B:= B + temp;   
    write(B);   
- A의 잔액 1000$, B의 잔액 2000$라고 가정할때
  - T1 -> T2 : A = 855$ , B = 2145$
  - T2 -> T1 : A = 850$ , B = 2150$
- 스케줄(schedule) : 트랜잭션의 실행 순서, 트랜잭션의 모든 명령어를 포함해야 하며, 트랜잭션이 커밋 상태가 되었다는 것을 나타내기 위해서 commit 명령어가 있다.
- T1과 T2는 순차적인 스케줄이다. 동시성을 고려하는 스케쥴은 순차적이지 않아도 괜찮다.
- T3 : T1 -> T2의 과정이나 동시성 고려한 스케쥴
  > T3:    
    read(A);   
    A:= A - 50;   
    write(A);  
    read(A);    
    temp := A*0.1;
    A:= A - temp;   
    write(A);  
    read(B);   
    B:= B + 50;   
    write(B);   
    commit;    
    read(B);   
    B:= B + temp;   
    write(B);   
    commit;   
- 두 번째 write(A); 상태를 보면 비일관성 상태이다. 동시 수행을 전적으로 운영체제에게 맡긴다면 비일관성 상태로 만드는 스케줄이 많을것이다. 
- 일관된 상태에 있게 스케줄을 실행하도록 하는 것은 데이터베이스 시스템의 몫이다. 데이터베이스 시스템의 동시성 제어(concurrency-control) 구성요소가 이 역할을 수행한다.
- 직렬 가능(serializable) 스케쥴 : 동시 수행한 스케줄의 결과가 트랜잭션을 하나씩 수행하는 결과와 동일한 스케줄

<br>

## 6. 직렬 가능성
- 순차적 스케줄은 반드시 직렬 가능성을 갖는다.
- read와 write 연산이 중요하다
  - I = read(Q), J = read(Q) : 둘다 읽기만 하기에 I와 J의 순서는 전혀 문제가 없다.
  - I = read(Q), J = write(Q) : I보다 J가 먼저 나온다면 I는 변경된 Q값을 읽게 된다. I와 J의 순서가 중요하다.
  - I = write(Q), J = read(Q) : J보다 I가 먼저 나온다면 J는 변경된 Q값을 읽게 된다. I와 J의 순서가 중요하다.
  - I = write(Q), J = write(Q) : 둘의 순서는 상관없으나 이후에 나오는 read에 의해 순서가 중요해진다. 뒤에 나오는 read는 나중에 실행된 Q값을 참고하기 때문이다.
- 둘 중 적어도 write라면 I와 J는 충돌(conflict)된다.
- 서로 충돌하지 않는 트랜잭션 I와 J는 순서를 바꿔도 상관없다. 충돌이 일어나지 않는 트랜잭션의 순서를 바꾼 스케줄과 원본 스케줄은 충돌 동등(conflict equivalent)하다고 할수 있다.
- 충돌 동등은 충돌 직렬 가능성으로 확장된다.
- 충돌 직렬 가능성 검사는 우선순위 그래프(정점 = 트랜잭션, 간선 = 가능한 순서 조합)로 확인가능하다.
- 우선순위 그래프에 사이클이 존재하면 충동 직렬 가능 스케쥴이 아니다.
- 트랜잭션의 직렬 가능성 순서는 선형 순서를 결정하는 위상 정렬을 통해 얻을 수 있다.
- 같은 결과를 만들더라도 충돌 동등하지 않은 두 스케줄이 존재할 수 있다.

<br>

## 7. 트랜잭션 고립성과 원자성
- 트랜잭션이 실패하면 원자성을 보장하기 위해 트랜잭션의 영향력 이전의 상태로 되돌려야 한다.
- 동시 실행을 보장하는 시스템에서 원자성을 보장하기 위해 시스템에서 수행하는 스케줄의 형태에 제한이 필요하다.

<br>

### 7-1. 복구 가능한 스케줄
- 특정 트랜잭션(A)이 다른 트랜잭션(B)의 결과를 읽거나 활용한다면 A는 B에 종속적이라 표현할 수 있다.
- 만약 B가 실패했다면 원자성 보장을 위해서 A도 취소해야 한다.
- 복구 불가능한 스케줄이란 모든 참조되는 트랜잭션이 커밋되기 전에 참조하는 트랜잭션이 커밋하는 스케줄을 의미한다.

<br>

### 7-2. 비연쇄적 스케줄
