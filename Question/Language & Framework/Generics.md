# Generics

---

## 면접 질문 예시

> "제네릭에 대해 설명해주세요"

---

<details>
  <summary><h2> 평가 요소 및 모범 답안</h2></summary>

  ### 1. 제네릭의 등장 배경 및 장점 이해
  - 포함내용
    * 제네릭 등장 이전 : 모든 컬렉션이 Object로 다루어져 다운 캐스팅 비용과 잘못 캐스팅 시 런타임 에러(ClassCastException)가 발생하는 문제가 존재
    * 제네릭 등장 이후 : 제네릭을 사용하여 컬렉션의 타입을 변수로 다루어 컴파일 타임에서 검증
      - 불필요한 다운 캐스팅과 런타임 에러를 제거
      - 가독성 및 유지보수성 향상

  ### 2. 타입 소거 특징 이해
  - 포함내용
    * 타입 소거 : Java Generics는 타입을 런타임에 보존하지 않고 컴파일 단계에서 소거, 필요한 곳에 자동 캐스팅, bridge method를 사용하여 타입 사용
      - List<String> -> List로 변환
      - instanceof 허용 불가 -> List<Integer>, List<String> 모두 List이므로
      - 배열 사용 불가 -> 어떤 타입의 배열인지 알 수 없음
      - 오버로딩 충돌 주의 -> List<Integer>, List<String>은 같은 타입의 매개변수로 취급
    * 리어파이드(reified) 제네릭 : 런타입에도 타입 인자가 남는 제네릭, Java에는 지원 안하므로 아래와 같은 방법을 사용
      - 타입 토큰(Class<T> type) 전달
      - Guava TypeToken, Jackson TypeReference 등 특수 래퍼 사용
     
    
    
  ### 3.모범 답안 예시
      "제네릭은 타입을 변수로 다루어 컴파일 시점에 검증하는 문법으로 불필요한 다운 캐스팅과 런타임 에러를 제거하고 가독성과 유지보수성에 장점이 있습니다  
      하지만, 타입 소거 특징으로 런타임에 타입이 사라지기에 배열 생성, instanceof 사용 불가 등의 문제가 있으며 부족한 부분은 타입 토큰과 같은 방법을 사용해 해결할 수 있습니다"

  ### 3.심화지식
  - 포함내용
    * 와일드 카드(?)
      - 타입을 모르는 컬렉션이므로 요소를 추가할 수 없고(null은 가능) 오직 Object로 읽어올 수만 있음
      - <Object>의 경우 Object 요소를 담을 수 있고 읽어올 때는 Object로 읽어온다는 차이가 있음
      - PECS(Producer Extends, Consumer Super) 규칙 :데이터를 읽는 쪽에는 ? extends T, 데이터를 쓰는 쪽에는 ? super T를 쓰라는 원칙
        * 컬렉션은 기본적으로 무공변이지만, 와일드 카드를 활용하여 공변, 반공변을 활용할 수 있음
        * ? extends T : 컬렉션으로부터 읽어올 때는 T의 하위 타입이어도 메서드에서 사용 가능(공변), 읽기 전용, 추가 불가(null 제외)
        * ? super T : 컬렉션에 저장할 때는 T가 저장하는 타입보다 상위 타입이어도 가능(반공변), 쓰기 전용, 꺼낼 때는 Object
