# Java Garbage Collection (GC)

---

## 면접 질문 예시

> "Java의 Garbage Collection이 무엇인지 설명해주시고, GC가 동작하는 기본 원리와 특징, 그리고 주요 알고리즘 및 튜닝 고려사항에 대해 말씀해 주실 수 있나요?"

---

<details>
  <summary><h2>평가 요소 및 평가 요소 별 모범 답안</h2></summary>

  ### 1. Garbage Collection의 정의 및 목적
  - 포함내용:
    - 정의: Java Garbage Collection은 JVM에서 객체가 더 이상 참조되지 않을 때 해당 객체가 사용하고 있던 메모리를 자동으로 회수하는 메커니즘이다.
    - 목적: 프로그래머가 명시적으로 메모리를 해제하는 부담을 줄이고, 메모리 누수 및 dangling pointer와 같은 문제를 방지하여 안정적인 메모리 관리를 가능하게 한다.
      - 메모리 누수 (Memory Leak) : 더 이상 필요하지 않거나 참조되지 않는 객체가 여전히 메모리에 남아 있는 상태를 의미한다.
        - 관리형 언어(Java, C# 등)에서는 가비지 컬렉터가 사용되지 않는 메모리를 회수하지만, 개발자가 불필요한 객체 참조를 계속 유지하면 그 객체들이 회수되지 않아 메모리 누수가 발생할 수 있습니다. 이는 장기간 실행되는 애플리케이션에서 메모리 사용량이 점진적으로 증가하게 되어 결국 시스템 성능 저하나 OutOfMemoryError를 유발할 수 있습니다.
      - Dangling Pointer : 이미 해제된 메모리 영역을 참조하는 포인터를 의미합니다.
        - C나 C++과 같은 수동 메모리 관리 언어에서는, 메모리가 해제된 후에도 해당 메모리 주소를 참조하는 포인터가 존재할 경우, 해당 포인터를 dangling pointer라고 합니다. 이 경우, 해당 포인터로 접근할 시 예기치 않은 동작이나 프로그램 충돌(크래시)을 일으킬 수 있습니다. Java와 같은 관리형 언어에서는 가비지 컬렉션으로 인해 dangling pointer 문제가 발생하지 않습니다.

  - <details>
    <summary>모범 답안 예시 :</summary>
    
    > "Java Garbage Collection은 JVM이 힙 메모리에서 더 이상 사용되지 않는 객체들을 자동으로 탐지하고 제거함으로써 메모리 관리를 담당하는 메커니즘입니다. 이를 통해 프로그래머는 메모리 해제에 대한 부담 없이 애플리케이션 로직에 집중할 수 있으며, 메모리 누수나 다른 메모리 관련 오류를 예방할 수 있습니다."
    </details>

  ### 2. GC의 동작 원리 및 단계
  - 포함내용:
    - 동작 원리:
      - Garbage Collector는 주기적으로 힙을 스캔하며 더 이상 참조되지 않는 객체를 찾는다.
      - 대표적으로 "Mark-and-Sweep" 알고리즘이 있으며, 필요에 따라 "Mark-and-Compact" 방식도 사용한다.
    - 세부 단계:
      - Mark 단계: 모든 객체를 검사하여 사용 중인(참조되는) 객체를 표시한다.
      - Sweep 단계: 마크되지 않은 객체들을 힙에서 해제한다.
      - Compact 단계 (선택적): 단편화된 메모리를 정리하여 힙의 연속성을 유지한다.

  - <details>
      <summary>모범 답안 예시 :</summary>
    
      > "Garbage Collector는 먼저 Mark 단계에서 각 객체가 참조되고 있는지를 확인하여 살아있는 객체들을 표시합니다. 이후 Sweep 단계에서 참조되지 않은 객체들을 힙에서 제거하며, 필요에 따라 Compact 단계에서 남은 객체들을 재배열하여 메모리 단편화를 줄입니다."
    </details>

  ### 3. Generational GC 및 주요 알고리즘
  - 포함내용:
    - Generational GC: JVM은 메모리를 Young 영역과 Old 영역(및 Java 8부터는 Metaspace)을 구분하여 관리하며, 일반적으로 대부분의 객체는 Young 영역에서 할당되고 곧 사라진다는 가정을 기반으로 합니다.
    - 주요 알고리즘:  
      - Serial GC: 단일 스레드를 사용하여 GC 작업을 수행하는 단순한 알고리즘.
      - Parallel GC: 여러 스레드를 사용해 동시에 GC 작업을 수행하는 방식으로, 처리량을 향상시킨다.
      - Concurrent Mark Sweep (CMS): 애플리케이션 정지 시간을 최소화하기 위해 대부분의 GC 작업을 애플리케이션 스레드와 병행하여 처리한다.
      - G1 GC (Garbage-First): 힙을 여러 영역으로 분할하여 우선순위가 높은 영역부터 GC 작업을 수행하며, 예측 가능한 일시 정지를 목표로 합니다.

  - <details>
      <summary>모범 답안 예시 :</summary>
    
      > "JVM은 Generational GC 방식을 사용하여 Young 영역에 할당된 객체는 대부분 빠르게 수거하고, 오래 살아남은 객체는 Old 영역으로 옮겨집니다. 주요 알고리즘으로는 Serial GC와 Parallel GC, 애플리케이션 중단 시간을 줄이기 위한 Concurrent Mark Sweep (CMS), 그리고 최신 환경에 적합한 G1 GC가 있으며, 각 알고리즘은 애플리케이션의 특성과 성능 요구에 맞게 선택됩니다."
    </details>

  ### 4. GC 튜닝 및 고려사항
  - 포함내용:
    - GC 튜닝: GC 옵션(예: JVM 옵션)을 통해 GC 동작 방식과 힙 크기를 조정하여 애플리케이션 성능을 최적화한다.
    - 고려사항: GC 일시 정지(Stop-The-World 현상) 영향을 최소화하는 것이 중요하며, 이를 위해 GC 로그 분석 및 주기적인 튜닝이 필요하다.

  - <details>
      <summary>모범 답안 예시 :</summary>
    
      > "애플리케이션 성능을 최적화하기 위해 JVM 옵션을 사용해 힙 크기와 GC 정책을 조정하는 것이 중요합니다. GC가 실행되면 일시적으로 모든 애플리케이션 스레드가 정지하는 'Stop-The-World' 현상이 발생하는데, 이를 최소화하기 위해 GC 로그를 분석하고 적절한 튜닝을 수행해야 합니다."
    </details>

  ### 5. 심화 지식
  - 포함내용:
    - GC 튜닝 사례: 실시간 애플리케이션에서는 CMS 또는 G1 GC 사용을 통해 정지 시간을 최소화하며, 배치 처리 시스템에서는 Parallel GC를 통해 처리량을 극대화하는 등의 전략이 있습니다.
    - 메모리 단편화: Compact 단계의 필요성과 이로 인한 성능 개선 효과.
    - 모니터링: GC 로그 분석, VisualVM, JConsole 등의 도구를 사용해 GC 성능과 힙 사용률을 모니터링하는 방법.

  - <details>
      <summary>모범 답안 예시 :</summary>
    
      > "심화적으로, 시스템의 특성에 따라 적절한 GC 알고리즘을 선택하고, GC 로그를 통해 애플리케이션의 GC 동작을 모니터링하여 성능 병목을 파악하는 것이 중요합니다. 예를 들어, 실시간 처리 애플리케이션에서는 CMS나 G1 GC를 사용해 'Stop-The-World' 시간을 줄이고, 대규모 데이터 처리에서는 Parallel GC를 통해 높은 처리량을 유지할 수 있습니다. 또한, 메모리 단편화를 줄이기 위해 Compact 단계가 중요한 역할을 하며, VisualVM이나 JConsole과 같은 도구를 활용해 주기적으로 모니터링하는 전략이 필요합니다."
    </details>
</details>
