<details>
  <summary><strong>AFS에 대해서 간단히 설명해 주세요</strong></summary>

<br>

AFS(Andrew File System)은 가능한 많은 클라이언트를 지원하기 위해(확장성) 클라이언트와 서버 간의 프로토콜을 설계한 파일 시스템으로 서버는 클라이언트에 항상 최신 파일이 open되는 것을 보장했습니다    
  
</details>

<details>
  <summary><strong>ITC 분산 파일 시스템(AFSv1)과 NFS의 차이에 대해 설명해 주세요</strong></summary>

<br>

블럭 단위로 클라이언트의 메모리에 캐싱한 NFS와 달리 AFSv1은 파일 전체를 로컬 디스크에 캐싱합니다  
즉, AFSv1은 Fetch 프로토콜로 파일의 전체 경로명을 전송하여 해당 파일을 로컬 디스크에 캐싱한 후 read(), write()와 같은 호출을 통해 캐시된 파일을 사용합니다. 이 때, 클라이언트는 서버에 파일 변경 여부를 TestAuth 프로토콜을 사용해서 캐싱된 파일이 최신 버전인지 확인합니다  
</details>



<details>
  <summary><strong>ITC 분산 파일 시스템(AFSv1)의 문제점과 AFS2에서 이를 어떻게 개선했는지 설명해 주세요</strong></summary>

<br>

AFSv1은 전체 경로명으로 파일을 찾는 것이 비싸고 TestAuth 프로토콜을 너무 많이 요청한다는 문제가 있었습니다  
AFS2에서는 전체 경로명을 서버가 아닌 클라이언트가 따라가면서 캐싱하는 방식을 사용하고(파일 식별자로 위치 표현), 캐싱된 파일이 변경된 경우 서버가 클라이언트에 콜백으로 변경 사실을 알려주는 방식으로 개선했습니다  
즉, 클라이언트와 서버 간의 상호작용의 횟수를 줄이는 방법으로 문제를 해결했습니다  
</details>

<details>
  <summary><strong>AFS에서 캐시 일관성은 어떻게 확보되나요?</strong></summary>

<br>

AFS는 파일이 닫히는 시점을 기준으로 변경 내용을 서버에 반영하고 콜백 무효화를 통해 오래된 사본은 자동으로 갱신하도록 유도하고 있습니다  
또한, 한 기계 내부에서는 Unix 시맨틱을 따라 프로세스 간 즉시 쓰기가 반영이 되고, 여러 기계 간에는 파일 닫기 시점이 가장 마지막인 파일이 서버에 반영 됩니다  
</details>

<details>
  <summary><strong>AFS에서 크래시 복구는 어떻게 이루어지나요?</strong></summary>

<br>

AFS는 클라이언트 재부팅 시 콜백 메시지를 받지 못할 수도 있고 서버 크래시 발생 후 콜백 메시지를 보낼 곳을 확인할 수 없습니다  
이를 해결하기 위해 클라이언트 재부팅 시 TestAuth 프로토콜을 사용해 유효한 캐시인지 확인하고, 서버 크래시 발생 시 모든 클라이언트에 유효한 캐시인지 확인해보라는 메시지를 보내거나 주기적으로 서버가 살아있는지 heartbeat 메시지를 통해 검사하는 방법이 있습니다  
</details>

<details>
  <summary><strong>NFS와 AFS 성능을 비교하여 언제 무엇을 사용해야 하는지 설명해 주세요</strong></summary>

<br>

파일을 처음 읽는 경우, 순차 쓰기(새 파일 생성) 시 NFS와 AFS의 성능은 유사합니다
큰 파일 재읽기 시 AFS는 로컬 디스크에서 읽기만 하면 되고 NFS는 서버에서 파일을 다운 받아야 하므로 AFS가 성능 상 유리합니다  
파일 덮어 쓰기, 큰 파일 중 일부 데이터만 접근 시 NFS는 필요한 데이터만 접근하면 되므로 전체 파일을 다운로드 해야하는 AFS보다 성능 상 유리합니다  

</details>
