<details>
  <summary><strong>VAX-11의 구조는 어떻게 되어있나요?(프로세스 공간과 시스템 공간으로 나누어 설명하세요)</strong></summary>

<br>  

  ### 프로세스 공간
  * P0 영역: 사용자의 코드와 힙이 존재하고 힙은 주소가 큰 쪽으로 증가한다
	* P1 영역: 주소가 작은 방향으로 증가하는 스택이 존재
  ### 시스템 공간
  * S0 영역: 운영체제 커널 및 시스템 코드.
  * S1 영역: 시스템 데이터 구조.
</details>

<details>
  <summary><strong>VMS 설계자들 메모리 소진을 막기 위해서 어떠한 방식을 사용했나요?</strong></summary>

<br>  

  1. 사용자 주소 공간을 두 개의 세그먼트로 나누어(P0, P1) 각 영역을 위한 페이지 테이블을 가지도록 하였다. 그 결과 스택과 힙 사이의 사용되지 않은 주소 영역을 위한 페이지 테이블이 필요가 없어졌다.
	2. 운영체제가 사용자 페이지 테이블들을 커널의 가상 메모리에 배치하여 메모리 압박을 더 줄였다.
</details>

<details>
  <summary><strong>커널 가상 메모리에 페이지 테이블을 넣으면 주소 변환 과정이 어떻게 변화하나요?</strong></summary>

<br>  

  * 변환 과정이 더욱 복잡해집니다. P0와 P1내의 가상 주소를 변화하는 과정을 설명하자면
  1. 하드웨어가 먼저 페이지 테이블에서 해당 페이지 테이블 항목을 찾아낸다.(하드웨어가 페이지 테이블 항목을 찾아내는 과정에서 시스템의 페이지 테이블을 먼저 검색해야 할 수도 있다.)
  2. 변환이 완료되면 하드웨어는 페이지 테이블 페이지의 주소를 알게된다
  3. 해당 페이지 테이블 페이지의 주소를 활용하여 원하는 메모리 접근에 대한 주소를 추론한다.
</details>

<details>
  <summary><strong>VMS에서 최적화 방법은 무엇이 있나요?</strong></summary>

<br>  

  ### 세그먼트된 FIFO
  * VMS에서 활용한 페이지 교체 최적화 방법으로 각 프로세스는 상주 집합 크기(RSS)라 불리는 보유 가능 최대 페이지 개수를 지정 받고 각 페이지들은 FIFO 리스트에 보관되며, 페이지 개수가 RSS보다 커지면 처음들어온 페이지가 쫓겨난다. FIFO 성능을 높이기 위해서 VMS는 두개의 second-chance-list를 만들었고 쫓겨난 페이지들에서 변경사항이 있으면 더티-페이지리스트에 수정이 없다면 클린-페이지 리스트에 보관한다. 이후 프로세스가 추가적으로 페이지가 필요한 상황이 발생하면 클린-페이지 리스트에서 첫 번째 페이지를 꺼낸다. second-chance-list의 크기가 클수록 LRU 알고리즘과 유사하게 동작된다.

  ### 페이지 클러스터링
  * 페이지의 크기가 작을수록 스왑할때 디스크의 I/O가 비효율적이고 이를 해결하기 위해 등장한 최적화 기법으로, 클러스터링 기법을 사용한다. VMS는 전역 더티 리스트에 있는 페이지들을 작업 묶음을 만들어서 한 번에 디스크로 보낸다. 운영 체제는 스왑 공간 어디든 페이지를 자유롭게 배치할 수 있어서 페이지를 그룹으로 묶어서 쓰는 것이 가능하다. 쓰기 횟수는 줄이고 한번에 쓰는 양을 늘려서 성능을 향상하는것이라 클러스터링 기법은 현대 시스템에서도 사용된다.
</details>

<details>
  <summary><strong>demand Zeroing 기법은 무엇인가요?</strong></summary>

<br>  

  * Demand Zeroing은 메모리 페이지를 초기화할 때 사용되는 기법으로, 페이지가 실제로 필요해질 때까지 "0"으로 초기화 작업을 지연시키는 최적화 기법입니다. 프로그램이 새 메모리를 요청하면 해당 메모리 영역은 초기 상태로 0으로 설정되어야 합니다. 하지만 이 작업은 프로그램이 해당 메모리를 실제로 사용할 때까지 지연됩니다.

  ### 작동 방식
    1. 프로세스가 새 페이지를 요청하면, 운영체제는 물리적 메모리를 즉시 할당하지 않고 논리적으로만 요청을 처리합니다.
    2. 페이지는 가상 메모리 테이블에서 "초기화 대기 상태"로 표시됩니다.
    3. 해당 페이지에 접근(읽기 또는 쓰기 시도)하려고 하면 페이지 폴트가 발생합니다.
    4. 운영체제는 물리적 메모리를 할당하고, 페이지를 0으로 초기화합니다.
    5. 페이지가 정상적으로 사용됩니다.

  ### 장점
    1. 메모리 초기화 비용 지연: 프로그램이 요청한 모든 페이지를 즉시 0으로 초기화하지 않으므로, 초기화 작업이 필요한 경우에만 수행되어 성능이 최적화됩니다.
    2. 메모리 사용 효율성 증가: 요청된 메모리 중 사용되지 않는 페이지는 초기화되지 않으므로, 자원이 낭비되지 않습니다.
</details>

<details>
  <summary><strong>copy-on-write 기법은 무엇인가요?</strong></summary>

<br>  

  * Copy-on-Write (COW)는 프로세스 간 메모리 공유를 최적화하는 기법으로, 메모리를 복사하지 않고, 데이터를 쓰기 시점에만 복사합니다. 부모 프로세스와 자식 프로세스가 동일한 페이지를 공유하여 메모리를 효율적으로 사용하며, 하나의 프로세스가 데이터를 수정하려고 하면 그때서야 메모리를 복사합니다.


  ### 작동 방식
    1. 프로세스가 fork 시스템 호출을 통해 자식 프로세스를 생성하면 부모와 자식은 동일한 메모리 페이지를 읽기 전용으로 공유.
    2. 읽기 작업은 부모와 자식 모두 동일한 메모리를 사용.
    3. 어느 프로세스에서든 페이지를 수정하려고 하면 페이지 폴트가 발생.
    4. 운영체제는 해당 페이지를 복사하여, 복사된 페이지를 수정 가능한 상태로 해당 프로세스에 제공.
    5. 나머지 공유 페이지는 계속 읽기 전용으로 유지.

  ### 장점
    1. 메모리 사용 절약: 수정이 필요한 경우에만 메모리가 복사되므로, 프로세스가 메모리를 효율적으로 사용.
    2. 빠른 프로세스 생성: fork 호출 시 부모와 자식이 동일한 메모리를 공유하므로, 초기 메모리 복사 작업이 필요하지 않음.
    3. 성능 향상: 불필요한 메모리 복사를 피하므로 CPU와 메모리 사용량이 최적화됨.
</details>