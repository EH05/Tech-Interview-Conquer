<details>
  <summary><strong>세그멘테이션과 비교하여 페이징을 사용하는 이유를 설명해 주세요</strong></summary>

<br>

세그멘테이션은 프로그램 논리에 맞춰 가변 길이의 블록으로 메모리를 나누는 방식입니다. 가변 길이의 블록은 크기가 달라 관리가 복잡하고 가변적인 크기 만큼 외부 단편화 문제가 발생할 수 있습니다    
페이징은 전체 메모리를 고정 크기 블록으로 나누는 방식입니다. 고정 크기의 블록을 사용하기에 관리가 간편하고 유연한 블록 사용으로 외부 단편화 문제를 줄일 수 있습니다  

<br>

* 외부 단편화 : 남아있는 메모리의 공간의 총 크기가 프로세스가 요청하는 메모리 공간보다 크지만 남은 공간이 연속적이지 않아 사용할 수 없는 문제
</details>

<details>
  <summary><strong>페이지와 프레임에 대해서 설명해 주세요</strong></summary>

<br>

가상 주소 공간을 일정한 크기의 블록으로 나눈 것을 페이지, 물리 메모리를 같은 크기의 블록으로 나눈 것을 프레임이라고 합니다  

</details>

<details>
  <summary><strong>페이지 테이블에 대해 설명해 주세요</strong></summary>

<br>

가상 페이지 번호와 물리 프레임 번호의 연결 관계를 저장하는 구조로 주로 메모리에 저장됩니다    
즉, 가상 페이지 번호를 이용하여 물리 프레임 번호를 페이지 테이블을 통해 확인할 수 있습니다  

</details>

<details>
  <summary><strong>페이지 테이블에 저장되는 비트에는 어떤 것이 있나요?</strong></summary>

<br>

페이지 테이블의 대부분은 물리 프레임 번호가 저장됩니다  
그 외에도 가상 페이지가 현재 물리 메모리에 존재하는지 확인하는 Valid Bit, 읽기/쓰기가 가능한지 나타내는 R/W bit, 사용자/커널 중 접근 가능한 모드를 나타내는 U/S 비트, 최근에 접근 된 적 있는 페이지인지 나타내는 Access bit, 수정된 적 있는 페이지인지 나타내는 Dirty bit 등이 저장됩니다 

</details>

<details>
  <summary><strong>주소 변환 과정에 대해 설명해 주세요</strong></summary>

<br>

가상 주소는 페이지 번호와 오프셋으로 이루어져 있습니다  
페이지의 크기가 4KB(2<sup>12</sup>)라면 한 페이지에는 0 ~ 2<sup>12</sup> - 1의 주소가 존재하고 이 부분이 오프셋, 나머지 상위 비트는 페이지 번호가 됩니다
CPU가 가상 주소를 참조하면 페이지 번호를 사용하여 페이지 테이블에서 물리 프레임 번호를 얻습니다. 그 후 물리 프레임 번호에 오프셋을 더해 실제 물리 주소를 구합니다  

<br>

* 물리 프레임 번호(물리 프레임의 시작점) + 오프셋 = 실제 물리 주소
* 영어 사전에서 단어를 찾을 때, 알파벳이 물리 프레임 번호이고 오프셋은 그 알파벳에서 몇 번째 위치에 단어가 있는지를 나타냅니다
  

</details>

<details>
  <summary><strong>페이지 테이블에서 발생하는 문제에는 어떤 것이 있나요?</strong></summary>

<br>

페이지 테이블은 메모리 낭비, 속도 문제가 발생할 수 있습니다  
단일 페이지에서 32비트 주소를 사용하고 페이지 크기가 4KB(2<sup>12</sup>)라면 페이지 번호는 20비트 즉, 2<sup>20</sup>개의 페이지가 필요합니다  
결국 테이블만 4MB가 필요하게 되고 프로세스마다 페이지 테이블이 만들어지므로 메모리 낭비 문제가 생길 수 있습니다  
주소 변환 시 페이지 테이블을 참조하기 위해, 그리고 실제 메모리를 사용하기 위해 두 번의 메모리 참조가 필요하고 이는 느린 속도로 이어질 수 있습니다  

<br>

* 메모리 낭비 해결 방안 : 다단계 페이지 테이블
* 느린 속도 해결 방안 : TLB를 활용한 캐싱

</details>
