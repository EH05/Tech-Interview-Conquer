<details>
<summary>TLB의 역할과 동작 원리에 대해 설명해주세요.</summary>
TLB는 주소 변환을 가속화하기 위해 자주 참조되는 가상 주소와 물리 주소의 매핑 정보를 저장하는 캐시입니다.  
주소 변환 과정에서 CPU는 먼저 TLB를 검색하여 변환 정보를 찾습니다. TLB에 변환 정보가 있다면 이는 TLB 히트라고 하며 빠르게 물리 주소를 반환하고, 없으면 TLB 미스로 페이지 테이블을 참조하여 변환 정보를 가져온 후 TLB를 갱신합니다.
</details>


<details>
<summary>TLB 미스가 일어났을 때 처리하는 방법에 대해서 설명해주세요.</summary>
TLB 미스 시 하드웨어 또는 소프트웨어가 페이지 테이블을 참조합니다.
하드웨어 기반 처리 방법에서는 CPU가 페이지 테이블에서 변환 정보를 가져와 직접 TLB를 갱신합니다.  
소프트웨어 기반 처리 방법은 운영체제가 예외 처리를 통해 페이지 테이블을 검색하고, 변환 정보를 TLB에 갱신합니다.  

  - **하드웨어 기반 처리**  
    - CPU가 내부적으로 페이지 테이블(base register 활용 등)을 참조  
    - 변환 정보(페이지 프레임 번호, 보호 비트 등)를 발견하면 **자동으로 TLB에 갱신**  
    - 미스를 일으킨 명령어를 **재실행**하여 이번에는 TLB 히트가 발생하도록 유도
  
  - **소프트웨어 기반 처리**  
    - 미스 발생 시 CPU가 **예외(trap)**를 발생 → 운영체제 커널 모드로 진입  
    - 운영체제의 TLB 미스 핸들러가 **페이지 테이블**을 검색해 변환 정보 획득  
    - TLB를 **특권 명령어**로 업데이트 후, 명령어를 재실행  
    - RISC 계열(MIPS 등)에서 자주 볼 수 있는 방식으로, 운영체제 입장에서 유연성↑, 하드웨어 설계 단순화
</details>


<details>
<summary>문맥 교환 시 TLB 관리 방법에 대해 설명해주세요.</summary>
문맥 교환 시 다른 프로세스의 변환 정보가 남아 있으면 주소 매핑이 충돌하는 등의 문제가 발생할 수 있습니다.
이를 방지하기 위해 TLB를 초기화하여 모든 항목의 유효 비트를 비활성화하거나, 
ASID를 활용해 프로세스별 변환 정보를 구분할 수 있습니다.
이는 TLB를 비우지 않고도 프로세스 간의 충돌을 방지합니다.  
  
  - **TLB 전체 무효화**  
    - 문맥 교환 시, 모든 TLB 엔트리의 **유효 비트(valid bit)**를 0으로 설정  
    - **장점**: 구현이 단순함  
    - **단점**: 새 프로세스가 실행될 때 모든 TLB를 다시 채워야 하므로 초기 TLB 미스가 증가할 수 있음
  
  - **ASID(Address Space Identifier) 사용**  
    - TLB 엔트리에 **ASID 필드**(프로세스 식별자)를 둬서 각 엔트리가 어떤 프로세스에 속하는지 구분  
    - 문맥 교환 시 운영체제가 CPU 레지스터에 **새로운 ASID**를 설정  
    - **장점**: TLB를 비우지 않고도 서로 다른 ASID 엔트리는 충돌 없이 공존 가능  
    - **단점**: 하드웨어 지원(ASID 필드, 레지스터) 필요, ASID 개수(비트 수)가 제한되어 있으면 충돌 가능성
</details>


<details>
<summary>TLB 교체 정책의 종류와 장단점은 무엇입니까?</summary>  
    
  TLB의 크기는 제한되어 있는 캐시이므로 새로운 매핑 시 교체가 필요합니다. 어떤 항목을 제거하는지에 따라 크게 LRU(Least Recently Used)와 랜덤(Random) 정책으로 나눌 수 있습니다.
  LRU는 가장 오래동안 쓰지 않은 항목을 제거하는 방식으로, 지역성을 최대한 활용하며 성능을 높일 수 있습니다. 하지만 구현이 복잡하고 연속적·순차적 패턴을 교체 정책이 잘못 해석하는 경우 오히려 효율성을 낮출 수 있습니다.
  랜덤은 무작위로 항목을 제거하는 방식으로, 구현이 간단하고 예외 상황에서도 안정적입니다. 하지만 성능 최적화 측면에서 효율성이 떨어질 수 있습니다.  
  
  - **LRU(Least Recently Used)**  
    - 가장 오랫동안 사용되지 않은 항목을 우선 제거  
    - **장점**: 보통의 프로그램 메모리 참조 패턴(지역성)에 잘 맞춰 성능 향상  
    - **단점**: 정확한 LRU 구현에는 하드웨어 오버헤드가 큼, 특정 패턴(순환 접근 등)에서 비효율적
  
  - **Random**  
    - 교체 대상을 무작위로 선정  
    - **장점**: 구현이 매우 간단, 극단적 패턴에서 LRU가 오히려 최악을 보일 수 있을 때 Random이 상대적으로 잘 동작하기도 함  
    - **단점**: 평균적 성능은 LRU보다 떨어지는 경향
</details>
